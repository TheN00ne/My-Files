Тег <script></script> 
console.log() / document.write() 
Комментарии 
Переменные / Создание переменных(let, const, var) 
Типы данных(Числа, строки, булевые...) 
Переобразование типов данных(num = Number(num)) 
Операторы (Математические, логические, сравнения...) 
Массивы (Создание массива, двухмерые массивы, основы про массивы) 
Объекты (Создание объекта, свойства, методы, основы про объекты)
Условия (if, else if, else) 
Свитчи (switch, case, break, default) 
Циклы (for, while, do while) 
Функции (Создание функции, ее вызов, стрелочная функция...) 
Замыкание
Больше про строки (методы строк)
Всплывающие окна (alert, confirm, prompt)
Interval / Timeout (set, clear)
Синхронность и Асинхронность
Деструктуризация
rest и spread 
ООП (Классы, наследование, инкапсуляция, полиморфизм...)
Больше про массивы (методы массивов) 
Больше про объекты (методы объектов) 
Math (abc, round, rand, pow...) 
Дата и время
bind(), call(), apply()
Дебаг
Сборка мусора 
Map, Set WeakMap, WeakSet (Их создание, их методы)
Промисы (Создание промиса, resolve, reject, then, catch, finally, all, race)
async, await и throw
BOM (window, location, history, navigation и screen)
DOM (Дерево DOM, навигация по дереву DOM, работа с сайтом через DOM, События...)
Модули (export, import...)



Тег <script> ... </script> - это тег, в котором будет подключатся JS код с помощью атрибута src (Этот тег пишится в HTML).

Если у тебя в одной папке JS++ две другие папки: HTML и JS, то чтоб через src у script в HTML обратиться к скрипту script1.js, который в папке JS нужно в src прописать так: "../JS/srcipt.js" две точи в начале означает, что мы обращаемся к папке, которая выше чем та, в которой находиться html файл	


console.log("Текст"); - это команда, которая выводит в консоль какой-то текст.

document.write("Текст"); - это команда, которая выводит на страницу какой-то текст.




//Коментарий - это строчный коментарий.

/* ... */ - это коментарий в несколько строк.




var name = 1; - это команда для создавания переменных (В var  можно записывать разные типы данных (строчный, булловские, численные)).

let - как var, но новое (разница в том, что let нельза вызвать за пределами условия или цикла, а var можно (но за пределами функции не будет работать не let, не var))

const - значение такой переменной постоянное (тоесть значение нельзя изменить в отличии от var и let) 




типы данных:

Undefined - Не определено (не найдено). 
Null - Ничего (не существует).
Boolean - Логическая переменная (true/false). 
Number - Числа (целые числа, числа с плавующей запятой) (вычеслительная ошибка = NaN).
BigInt - Как Numbers, но эта переменная длиная (в конце пишится буква n (1294638545728465286542975472786542874n)).
String - Строка (строки пишутся в одинарных скобках '', парных "", и обратные ``).
Symbol - Символ!!!!!
Object - Объект (вмещает в себя свойства и методы).
Function - Функция(как объект, но функция).

console.log(typeof переменная) - Выводит тип данных переменной

(Массив - это объект)




переобразование типов данных:

имя переменной = тип данных(на что менятся).

let a = 5; - переменная а с типом данных Number.
let b = false;
a = String(a); - тип данных у переменной а меняется на String с Number и пресваивает значение себя же(но уже как число, а не цифру).
a = Boolean(b); - тип данных у переменной а меняется на Boolean с String и присваивает значение переменной b, тоесть false.




операторы:

операнд - это то, к чему применяется оператор, их еще называют аргументами (6 - 5; тут 6 и 5 - это операнды) .

Операторы бывают бинарные и унарные:
Бинарные - те, которые применяются к двум операндам (6 - 5; тут "-" - это бинарные оператор).
Унарные - те, которые применяються только к одному операнду (-5; тут "-" - это унарный оператор).

Математические операторы:
"+" - додавание (4+2).
"-" - отнимание (4-2).
"*" - умножение (4*2).
"/" - деление (4/2).
"%" - остаток от деления (3/2).
"**" - возвести в степень (2**4 (2 в 4 степени)).

Строки также можно додавать (строки можно додавать даже к числам, но конечный результат будет с типом данных "строка").

Если строку, внутри которой цифра отнять/умножить/поделить на число то конечный тип данных будет числом, а не строкой ("20" * 2 = 40 (40 - это число, а не строка)). 
Если к строке, внутри которой число поставить унарный оператор то тип данных конечного результата будет числом (-"4" = -4 (-4 - это число, а не строка)).

Оператор присваивания:
let a = 5; "=" - это оператор присвоения
let b = 8 - (let c = 6 - a) - оператор присваивания может быть внутри другого вычисления(переменная b будет равна 8 - (с = 6 - 5) => 8 - (c = 1) => 8 - 1 = 7).

Присваивать значение можно по цепочке (a = b = c = 5).

С помощью оператора присваивания можно сокращать математические запеси:
a += 5  - (а = а + 5).
а -= 5  - (а = а - 5).
а *= 5  - (а = а * 5).
а /= 5  - (а = а / 5).


Инкремент - а++ - увеличить на один.
Декремент - а-- - уменьшить на один.
Их также можно записать перед переменой/числом (++а; --5).

Операторы сравнения:
Больше - ">" (5 > 4).
Меньше - "<" (4 < 5)/
Больше или равно - ">=" (5 >= 3)
Меньше или равно - "<=" (5 <= 7)
Равно(для проверки на равенства) - "=="  (5 == 5)
Не равно - "!=" (5 != 3).
Строгое равно - "===" (проверяет равенстро без приведении типов (0 === '0'  =>  false)).
Строгое не равно - "!==" (проверяет не равенстро без приведении типов (0 !== '0'  =>  true)).


Если мы сравниваем строки, то они сравниваються по:
Алфавиту("Б" > "А").
Если вначале слова буквы совпадают, но у второго слова символов больше, то больше то слово, у которого больше символов ("Привет" > "Приветствую").
Если слова одинаковые, но одного из слов есть где-то верхний регистр, то такое слово больше ("Белка" > "белка").   


Операторы стравнение возвращают true или false.

Если мы сравниваем разные типы данных, то они превратятся в одинакавые ("05" == 5  => 5 == 5 => true) (за исключением оператора строгово равенства).


оператор instanceof:

Этот оператор выводи true если какой-то объект является экземпляром какого-то класса, или же false - не является.
(obj instanceof Class).

Но этот оператор также выведет true, если проверить какой-то объект с классом, который не является родителем этого объекта, а является родителем класса, который в свою очередь является родителя объекта.
Просто говоря этот оператор учитывает наследование.

Чтоб наследование не учитывалось надо использывать оператор сравнения "==".


Логические операторы:
Или - "||" (console.log(5 || 3) //5). 
И - "&&" (Каждый операнд преобразуется в логическое значение, если результат false, то все останавливается и возвращается исходное значение этого операнда, а если все операнды были true, то вернется значение последнего) (console.log("5" && "false" && "true") //false  или (console.log("5" && "8") //8). 
Не - "!" (Возвращает противопаложное значение; console.log(!true) //false). 

оператор нулевого слияния (??):
оператор нулевого слияния (??) проверяет: какой операнд является оприделенным, а если все операнлы оприделенные, то вернет первый операнд.
Пример:
let a = "Hello";
let b; // Не определена 

console.log(a ?? b) // Hello (переменная а, потому-что она определена в отличии от переменной b) (если сравнивать null и undefined, то выведеться undefined) (а если null/undifined и другой тип данных, то выведется другой тип данных).


Условный оператор "?":
Оператор, который стоит в условии и позволяет вернуть значение, если условие верное (записывается так: (условие) ? "Значение": (условие2) ? "Значение2": ... "ЗначнниеN";).
Пример:
let age = prompt('Возраст?', 18);
let message = (age < 3) ? 'Здравствуй, малыш!' :
  (age < 18) ? 'Привет!' :
  (age < 100) ? 'Здравствуйте!' :
  'Какой необычный возраст!';

alert( message ); 




Массивы

Массив - это объект, который хранит в себе упорядоченные колекции.

Создание массива - let arr = [1,2,3];

Бывают многомерные массивы, многомерный массив - это массив, который хранит в себе другие массивы.

двухмерный массив - let arr2 = [[5,2], [5,2]]

arr[0] - это первый элемент в массиве, в квадратных скобках стоит индекс элемента, отщет идет с нуля. 




Объекты

Объект - это тип данных, который хранит именованые (Есть имя(ключ), которое всегда типа данных - строка, и есть его значение - всегда любой тип данных).

Создание объекта - let obj = {name: `Dima`, age = 15}

Чтоб обратистя к свойству или методу какого-то объекта нужно обратится к объекту, а потом через точку уточнить, к какоиу свойству/методу мы обращаемся (obj.name).




if - команда для создания условия (if - если).

else if -команда для условия если не подошло "if" (пишится после "if").

else - команда для условия если не подошли все условия (пишится в конце).	




switch - команда для проверки.

case: - случий.

break - команда которая пишится в конце случия.

default: - это команда, которая пишится в конце если не подошол не один случий.




тело цикла - (начало; условие;шаг).  	

for - это цикл, который пишится как: for(тело цикла) {цикл}.

while - это цикл, который пишится как: while(условие) {цикл; шаг}.

do while - это цикл который сначало делает а потом думает: do{цикл; шаг;} while(условие). 

for(i = 0; i >= 20; i++)
{ 
  if(i > 10)            
{break;}                => Если i > 10 то остановить функцию. 
}


for (i = 0; i >= 20; i++)
{
  if(i > 10)
{continue;}	        => Если i > 10 то пропустить условие;
}




все про функции:

function имя(параметр1, параметр2, ...) {} - Создание функции (параметры не обязательны) (чтоб функция работала ее надо вызвать).

имя функции(значение параметра1, значение параметра2 ...) - Вызов функции.
Параметрами функции могут быть любые типы данных, даже функция!

Function Expression (Функциональное выражение) - это когда мы переменной присваиваем функцию(у такой функции не обязательно должно быть имя)(в конце такой переменной-функции должна стаять кома с запятой) (также в переменную можно пресвоить уже существующию функцию) 
Пример: 
	let sayHi = function()
	    {
  		alert( "Привет" );
	    };
(вызывать такую функцию надо всегда после ее создания(плюс в том, что мы можем создать такую переменную-функцию перед циклом, в котором создадим функцию и после цикла надо переменной присвоить эут функцию, тоесть мы сможем вызвать функцию вне цикла)).

return результат - Прекрощает функцию и возвращает результат написаный после слова return.
	
Функция высшево порядка - функция которая принимает или возвращает другую функцию как аргумент(параметр).

Колбэк функция - это функция, которая является параметром функции высшово порядка.

Пример функции высшего порядка и колбэка:

function callBack(b){
    console.log("Another", b);
}

function high(func){
    func(3);
}

high(callBack);

Рекурсия - это когда функция вызывает внутри себя саму себя.


Стрелочная функция записывается так:
let func = (аргументы) => {return...}

Если у функции всего один аргумент, то ее можно записать без скобок в начале. ( a => {console.log(a)} );
Если у функции нет аргументов, то скобки всеровно должны присутствывть. ( () => {console.log("Hello!")} );
Если у функции нет return, то фигурные скобки писать не обязательно, даже если там есть действие. ( () => console.log("Hello!") );




Замыкание

Область видимости — это зона доступности переменных.

Переменные бывают глобальные и локальные.
Глобальные - те, к которым можно обратится в любой точке кода.
Локальные - те, к которым можно обратится только в блоке, в котором они находятся(например только в функции, условии, цикле и т.п.).

Замыкание это функция, у которой есть доступ к своей внешней функции по области видимости, даже после того, как внешняя функция прекратилась.

function person() {
  let name = 'Peter';

  return function displayName() {
    console.log(name);
  };
}
let peter = person();
peter(); // выведет 'Peter'

В этом примере мы вызываем функцию person, которая возвращает внутренюю функцию displayName и сохраняет эту внутреннюю функцию в переменную peter.
Когда мы вызываем функцию peter(которая на самом деле ссылается к функции displayName), имя “Peter” выводится в консоль.
(Результат функции person это функция displayName(потому-что она - это return функции person) и по-этому переменнная peter, которая равна функции person на сомом деле ссылается на функцию displayName).
(Внутреняя функция displayName имеет доступ к переменным внешней функции person и по-этому это замыканием).
Плюс использования замыкания в том, что при замыкании внутреняя функция получает переменные внешней функции и использовать эти переменные можно только в облости внешней функции, а сноружи изменить переменные нельзя.




Больше про строки

В обратных кавычках можно создавать многострочний текст:

console.log(`Hello!
My name is 
Dima`) //Выведеться в несколько строк

(Чтоб создать в одинарных или двойних кавычках многострочный текст нужно использовать /n, об этом написано ниже, в спецсимволах).


шаблоная строка:

Шаблоные строки объявляются в обратных кавычках (``)

В шаблонной строке с помощью синтаксиса ${ } можно использовать любые выражения JavaScript.
Например: console.log(`Hello my name is ${name}, I'm ${age}`.);


Спецсимволы:

Все спецсимволы начинаются с обратного слеша

\n - Перевод строки.
\t - Делает отступ.
\\ - С помощью него можно добавить в текст обратный слеш(если в текст прописать просто \, то он не будет выведен потому-что \ воспринемается как вызов спецсимвола).
\' - С помощью него можно выводить в текст одинарную кавычку.
\" - С помощью него можно выводить в текст парную кавычку.
\u{КОД} - С помощью него можно выводить в консоль символы (/u{1F60D} - выведет смайлик).		 

str.length - Выводит количество символов в строке (не считая внешние кавычки).
str.includes("часть строки", номер символа, на котором должна быть нужная часть строки(не обязательно)) - 
- выводит true, если такая часть строки есть в строке и она начинается с какого-то места или false - если такой части строки нет в строке или она находится не на своем месте.
(let srt1 = "string"; str1.includes("str",0)) //true, потому-что в строке str1 есть часть srt и она начинется с 0.

str.trim() — Убирает пробелы в начале и конце строки.
str.repeat(n) — Повторяет строку n раз.
str.slice(start, end) - Возвращает часть строки от start до end.

Чтоб вывести какой-то символ в строке нужно прописать после имени переменной-строки в квадратных скобках номер этого символа (srt[0] - первый символ строки).

Для того, чтоб перевести строку в нижний регистр нужно использовать toLowerCase() (str.toUpperCase()).
Для того, чтоб перевести строку в верхний регистр нужно использовать toUpperCase() (str.toUpperCase()).




alert("Текст"); - Это окно с одним вариантом.

confirm("Текст"); - Это окно с двумя вариантами.

prompt("Текст", "Начальное значание(не обязательно)"); - Это окно с текстовым полем ввода.




setInterval(Имя функции, количество микросекунд между функией, параметры функции(если они есть)) - Это конанда, которая устанавливает интервал между исполнением функции (Как цикл, но с перерывом).

clearInterval(Имя интервала) - Это команда, которая останавливает Интервал.

setTimeout(Имя фуннкции, количкство микросекунд до функции, параметры функции(если они есть)) - Это команда которая, устанавливает таймер до исполненя функции (Исполняет функцию один раз). 

clearTimeout(Имя таймера) - Это команда, которая останавливает таймер.




Синхронность и Асинхронность

Синхронные операции - это когда код выполсяеться сразуже(console.log(), document.write()).
Асинхронные операции - это когда код выполнится через какое-то время(setTimeout(), setInterval()).

Если setTimeout() таймер поставить 0, то она все равно будет асинхронной операцией и выполнеться последней.




Деструктуризация

Деструктуризация позволяет разбивать объект или массив на переменные при присвоении:

let arr = ["Dima", "Ilyin"];

let [firstName, lastName] = arr;

console.log(firstName); //Dima.
console.log(lastName); //Ilyin.


Также можно пропускать элемент массива з помощью запятых:

let [firstName, , lastName] = ["Dima", "abcd" "Ilyin"]; //abcd пропустилось 

console.log(lastName); //Ilyin.		




Остаточные параметры(rest) и оператор расширения(spread)

Вызывать функцию можно с любым количеством аргументов независимо от того, как она была определена:
	function func(a, b) //У функции может быть всего два аргумента 
	{ console.log(a + b) } //Выводить в консоль сумму a и b
	
	func(1,2,3...) //3, не смотря на то, что мы задали много аргументов учиталось только два первых: a и b(1 и 2).


Если мы хотим собрать все лишние аргументы в массив то нужно использовать это еще один аргумента в конце, но перед ним поставить три точки (...) - остаточные параметры(rest):
	 function func2(a, b, ...rest) //...rest - это все лишние аргументы. 
	{ console.log(`Summ is ${a + b}, rest is ${rest}`) } //Выводить в консоль сумму a и b и лишние аргументы.
	
	func(1,2,3,4,5...) //Summ is 3, rest is 3,4,5... те аргументы, которые идут после a и b (1 и 2) будут лишними тоесть rest.


Все аргументы функции находятся в псевдомассиве arguments под своими порядковыми номерами (Но у стрелочной функции нет arguments также как и this):
	function func3()
	{
	console.log(arguments);
	}

	func3(1,2,3,4) //1,2,3,4 Выводит массив всех элементов.


Чтоб извлечь элементы из массива в список нужно использовать оператор расширения(spread) (...) пишится также как и остаточные параметры, но делает все наоборот:

let arr = [3, 5, 1];
alert( Math.max(arr) ); // NaN

Но

let arr = [3, 5, 1];

alert( Math.max(...arr) ); // 5 (оператор "раскрывает" массив в список аргументов)


Оператор расширения может раскрывать любой перебераемый элемент(строка, массив, символ):
	let str = "String";
	console.log(...str); //S t r i n g.


Если ... располагается в конце списка параметров функции, то это «остаточные параметры»(rest). Он собирает остальные неуказанные аргументы и делает из них массив.
Если ... встретился в вызове функции или где-либо ещё, то это «оператор расширения»(spread). Он извлекает элементы из массива.




ООП

Объект - это сущность, способная сохранять информацию про себя и обеспечивающая набор операций(методов).


Свойства: Имя, возрост, вес, рост... (Характеристика объекта).
Методы: Ходить, писать, рисовать,говорить...(Действия (Функции), котрые совершает объект).


Class - Это шаблон для создания объекта.


constructor - это строка, внутрь которой добавляеться характеристики объекта.


Экземпляр класса это объект, который создается от какого-то класса, и содержит в себе все методы и свойства этого класса.


this - это контекст, который указивает на элемент, в котором он находиться.
new - это контекст, который создает новый объект на основе какого-то класса.


Статические методы и свойства.

Статическими называються свойства и методы, к которым объекты не имеют доступ, к таким свойствам и методам имеет доступ только класс.

static name = `I am class`. //Создание статического свойства.
static sayHello() {console.log(`Hello`)} //Создание статического метода.


Все объекты наследуються от класса Object

объект можно создать от класса Object
вот-так: var person = new Object({свойства и методы})


prototype - возвращает прототип объекта (ОБЪЕКТ-БОЛВАНКУ), то на что ссылается объект (Доступен только функциям-конструкторам (классам)) (Простыми словами: мы спрашиваем у класса: "Какой прототип ты создаешь?").

__proto__ - возврощает прототип объекта (ОБЪЕКТ-БОЛВАНКУ), то на что ссылается объект (Доступен только объектам) (Простыми словами: мы спрашиваем у объекта: "От какого прототипа ты создаешься?").


class Auto{
 constructor(title){
   this.title = title;
 }
}

let audi = new Auto(`Audi`)

Auto.prototype //Выведет прототип объекта {constructor: ..., function}
audi.__proto__ //Выведет прототип объекта {constructor: ..., function}

Также можно делать ципочку из __proto__ если объект - это экземпляр класса, который отнаследовался от другого класса.

class Bike extends Auto(){
 constructor(title){
  super(title)
 }
}

let bmw = new Bike(`BMW`)

bmw.__proto__ - Выведет прототип объекта от класса Bike
bmw.__proto__.__proto__ - Выведет прототип объекта от класса Auto

ООП построено на Наследовании, Инкапсуляции и Полиморфизме


Наследование - это когда мы наследуем с одного класса другой (то-есть все свойства и методы с одного класса передаются в другой класс) 	
extends - команда, которая указивает наследование одного объекта от другого.
super - метод, в который нужно записывать свойства отнаследованые от другого объекта.



Инкапсуляция

Свойства перед которыми пишится "#" - Это приватные свойства: свойства к которым нельзя обратится из вне.   

Геттеры (get):
Геттер - это метод, который используется для получения значения свойства объекта. Геттеры позволяют выполнить какой-либо код при попытке доступа к свойству. Они объявляются с использованием ключевого слова get перед именем метода.

*Геттер - это метод объекта, который используется для получения значения определенного свойства.
*Геттер объявляется с использованием ключевого слова get перед именем метода.
*Геттер не принимает аргументов и должен всегда возвращать значение.
*Геттер вызывается без вызова как метод, т.е., он выглядит как обычное свойство.

get fullName() {
    return `${this._firstName} ${this._lastName}`;
}

const person = new Person("Иван", "Иванов");
console.log(person.fullName); // "Иван Иванов"


Сеттеры (set):
Сеттер - это метод, который используется для установки значения свойства объекта. Сеттеры также позволяют выполнить какой-либо код при попытке установить значение свойства. Они объявляются с использованием ключевого слова set перед именем метода.

*Сеттер - это метод объекта, который используется для установки значения определенного свойства.
*Сеттер объявляется с использованием ключевого слова set перед именем метода.
*Сеттер принимает один аргумент (новое значение), которое вы хотите установить для свойства.
*Сеттер не должен возвращать значения и обычно используется для установки значений внутри объекта.

class Circle {
  constructor(rad) {
    this._rad = rad;
  }

  get readRadius() {
    return this._rad;
  }

  set writeRadius(newRadius) {
    if (newRadius > 0) {
      this._rad = newRadius;
    } else {
      console.error("Радиус должен быть положительным числом.");
    }
  }
}

const circle = new Circle(5);
console.log(circle.readRadius); // Вызов геттера, возвращает радиус

circle.writeRadius = 7; // Вызов сеттера, устанавливает новый радиус
console.log(circle.readRadius); // Вызов геттера с новым радиусом

circle.writeRadius = -2; // Попытка установить отрицательный радиус
// Выведет сообщение об ошибке: "Радиус должен быть положительным числом."



Полиморфизм - идея заключается в способности вызывать один и тот же метод для разных объектов, и при этом каждый объект реагирует по-своему.



Интерфейс - это класс в котором есть свойства и методы, но нет их реализации, и от класса-интерфейса нследуются обычные классы 
(то-есть в классе-интерфейсе можно посмотреть: какие свойства или методы есть у класса без реализации)
В классе-наследнике от интерфейса должны быть как минимум все те свойства и методы, которые были у класса-интерфейса 



Абстракция - это тоже самое что и интерфейс, но необезательно, чтоб в классе-наследнике были все те свойства и методы класса-абстракции



Композиция - это когда мы создаем несколько классов и они будут находится в другом классе(дополнять его)
(сами по себе классы, которые находятся в другом классе практически безполезные, а вот когда они в другом классе тогда они очень полезные)

Делегирование - это когда метод в главном классе вызывает подобные между собой методы более простых классов.


Агрегация - это как композиция только мы у главного класса в конструтор создадим свойство, и когда будем создовать экземпляр этого класса, то укажим на место этого свойства класс, который будет реализован как агрегация
(то-есть этот класс не будет зависеть от главного класса, и он может находится в несколько классах сразу)




Больше про массивы

массив мажет в себе хранить разные типы данных, даже объект!

let arr = [[0,5],[2,8]]; - двухмерный массив.

arr.length - Количество элементов в массиве.
массив можно скоротить с помощью свойства length (Допустим у нас есть массив arr с 3 элементами, его можно сократить до 2 ват-так: arr.langth = 2).До
Допустим у нас есть массив arr с 2 элементами, чтоб добавить еще один элемент к массиву arr надо: arr[2] = 7 (третий элемент массива = 7)

arr.unshift(6) - добавляет в начало массива arr элемент, который равен 6.

arr.shift() - удаляет элемент в начале массива arr и переводит второй элемент на место первого, третий на место второго и т.д. 

arr.push(6) - добавляет в конец массива arr элемент, который равен 6.

arr.pop() - удаляет последний элемент в массиве.

delete arr[1] - удаляет второй элемент массива (но количество элементов в массиве остаеться темже).

arr.splice(с какого места будет идти отчет,сколько элементов удалить считая от элемента корторый мы выбрали в прошлом пункте) - удаляет несколько элементов (если хотим удалить объекты с конца то нужно записать место с которого будет идти отчет отрецательным) (и количество элементов в массиве уменьшится).
arr.splice(с какого места будет идти отчет,сколько элементов удалить считая от элемента корторый мы выбрали в прошлом пункте,на что заменить) - заменяет значение уже существующего элемента.
arr.splice(номер будущего элемента в массиве,0,элемент который я хочу добавить) - добавляет элемент в массив.

let arr2 = arr1.concat(элемент которй мы хотим добавить к остальным(не обязательно)) - копирует существующий массив (и дополняет его новым элементом, но это не обязательно)).

indexOf(что искать, откуда искать(не обязательно)) - возвращает индекс элемента в массиве (-1 - если элемента в массиве нет).

includes(что искать, откуда искать(не обязательно)) - возвращает есть элемент в массиве или нет (true/false).

arr.sort() - Рассортировать массив по возрастанию (сортирует элементы как строки, тоесть "215" < "8") (чтоб сортировать нормаьно надо прописывать свой сортировщик).

Но можно сортировать как числа:

arr.sort((a, b) => a - b) - от меньшого к большему
arr.sort((a, b) => b - a) - от большого к меньшему

arr.reverse() - Отзеркалить массив.

arr.join("разделитель") - переобразовывает массив в строку и раздиляет элементы массива "разделителем".

str.split("разделитель") - переобразовывает строку в массив и части строки раздиляет повторяющемся символом "разделителем".

Array.isArray(имя массива) - проверяет является элемент массивом или нет(используються для того, чтоб понять элемент это объект или массив).

for of - ( for(let i of arr) ) - Этот цикл проходится по всем элементам массива arr, помещая элементы в переменную i по очереди.

arr.forEach(function(элемент, индекс, массив){console.log(элемент + " " + индекс + " " + массив)}) - Этот цикл позволяет запускать функцию для каждого элемента массива.

arr.map(function(элемент, индекс, массив){}) - вызывает функцию для каждого элемента массива и возвращает массив результатов выполнения этой функции (отличие от forEach в том, что forEach ничего не возвращает, а map возвращает).
	
arr.filter(function(элемент, индекс, массив){}) - Возвращает из массива все те элементы, которые удовлетворяют какое-то условие(которое написано функции) (отличие от map в том, что map при проверке условия вернет массив из true/false, а filter вернет массив из значений).
arr.filter(Boolean) -  Метод filter(Boolean) используется для удаления элементов массива, которые приводятся к логическому значению false.
В JavaScript filter оставляет только те элементы массива, для которых функция обратного вызова возвращает true. Если функция возвращает false,
элемент исключается из результирующего массива.



Больше про объекты

Объект можно создать двумя способами:

1) let obj = new Object;
2) let obj = {};

Свойства: Имя, возрост, вес, рост... (Характеристика объекта).
Методы: Ходить, писать, рисовать,говорить...(Действия(Функции), котрые совершает объект).

Свойством объекта может быть любой тип данных, даже объект.

Объекту можно добавлять новые свойства, изменять и удалять их вне объекта:
 
let obj = {} //Создаем пустой объект obj.
obj.name = "Dima"; //Добавляем объекту obj свойство name со значанием "Dima".

console.log(obj) //{name: "Dima"};


obj.name = "Alex"; //Теперь имя объекта не Dima, а Alex.


delete obj.name; - Удалит свойство name у объекта obj.


Копированние объектов и ссылки:

Если мы копируем переменну от другой переменной и потом меняем ее значение то значение первой переменной остается неизменной:
	let a = 5; //Переменная a = 5.
	let b = a; //Переменная b = a = 5.
	let b = 3; //Переменная b меняет свое значение с 5 на 3.
	console.log(`a is ${a}, b is ${b}`); //a is 5, b is 3 (b поменяла свое значение, а a - нет).

Но с объектами такое не работает, если создать объект от другого объекта и потом его свойства/методы изменить, то изменитя и первый объект
(потому-что при копировании объекта объект копирует ссылку на этот объект, но объект не дублируется как переменная).

Но, чтоб все таки копировать объект и сделать его независимым надо использовать метод Object.assign(объект, с которым мы работаем, объект от которого клонируем1,объект от которого клонируем2, ...);
Пример:
	let obj1 = {name: "Dima", age: 15} //Создаем объект obj1 со свойствоми name и age и их значениями соответствено "Dima" и 15.
	let obj2 = {} //Создаем пустой объект obj2.
	Object.assign(obj2, obj1); // клонируем obj2 от obj1.
	obj2.name = "Pavel"; //Меняем имя у obj2 с "Dima" на "Pavel".
	console.log(`name1 is ${obj1.name}, name2 is ${obj2.name}); //name1 is Dima, name2 is Pavel (name у obj2 поменялся на Pavel, а у obj1 остался Dima).

Опциональная ципочка:

Опциональная ципочка позволяет проверять свойство другого свойство (Если какого-то свойства в ципочке свойств нет, то выведеться ошибка,
а опциональная ципочка в таком случаи выводит не ошибку, а undefined)

Опциональная ципочка между свойствами пишится не просто через точку, а с вопросительным знаком перед точкой.  


let user = {
 // fullName: {
 //   firstName: "Dima"
 //   lastName: "Ilyin"
 // }	
}

console.log(user.fullName.lastName) //ошибка (потому-что свойства fullName и lastName нет).

console.log(user?.fullName?.lastName) //undefined (потому-что свойства fullName и lastName нет, но использывалась опциональная ципочка).



Оператор in:


Оператор in проверяет наличие свойства в объекте:

console.log("имя свойства(обязательно в кавычках)" in имя объекта) //true/false.


let obj = {name: "Alex"}

console.log("name" in obj) //true.



for in

Цикл for in создает переменную и присваивает ей ключи какого-то объекта по очереди(применется для объектов):

let obj = {title: "milk",price: "$0.6"} //Создаем объект obj со свойствами title и price.

for(let key in obj){ //Присваиваем по очереди переменной key ключи(свойства) объекта obj.
     console.log(key + ": " + obj[key]) //Выводим в консоль key:, а потом значение ключей(свойств) объекта obj (надо прописывать не через точку(obj.key), а в квадратных скобках (obj[key])).
}

(цикл for of нужен для массивов или строк, а for in - для объектов).




Функция-конструктор

Функции-конструкторы помогают создать несколько однотипных объектов.

Функции-конструкторы всегда начинаются с большой буквы(Это просто договоронность).

Функция-конструктор вызывается при помощи оператора new.


Функции-конструкторы это как классы, а точнее это классы функции конструкторы.


function User(name)
{
	this.name = name;
	console.log(name)
}

new User("Alex"); //Создастся новый объект со сойством name = "Alex" и выведится в консоль;

new User("Dima"); //Создастся новый объект со сойством name = "Dima" и выведится в консоль;




Math

Math.abs(num); - Возвращает модуль числа.

Math.min(num1, num2); - Возвращает минимальное число из нескольких.

Math.max(num1, num2); - Возвращает максимальное число из нескольких.

Math.floor(x) - Возвращает значение числа, округлённое к меньшему целому.

Math.ceil(x) - Возвращает значение числа, округлённое к большему целому.

Math.round(num); - Возвращает значение числа, округлённое до ближайшего целого.

Math.random(); - Вибирает рандомное число от 0 до 1.

Math.pow(num, stepen); - Возвращает какое-то число в какой-то степени.

Math.sqrt(num); - Возврощает квадратный корень числа.

Math.sign(x) - Возвращает знак числа, указывающий, является ли число положительным, отрицательным или нулём.




Дата и время:

Чтоб работать с датой и временем нужно создать объект от класса Data().
 (let date = new Date()).

У даты есть такие аргументы как: year, month, date, hours, minutes, seconds, ms.
 (new Date(year, month, date, hours, minutes, seconds, ms).
 (Также надо помнить, что отсчёт месяцев month начинается с нуля 0).


Для доступа к компонентам даты-времени объекта Date используются следующие методы:

getFullYear() - Получить год (из 4 цифр).
getMonth() - Получить месяц, от 0 до 11.
getDate() - Получить число месяца, от 1 до 31.
getDay() - Получить номер дня в неделе (неделя в JavaScript начинается с воскресенья, так что результат будет числом от 0(воскресенье) до 6(суббота)).
getHours() - getMinutes(), getSeconds(), getMilliseconds() - Получить соответствующие компоненты.
getMinutes() - Получить значение минут. 
getSeconds() - Получить значение секунд.

	
Для установки даты используются такие методы:

setFullYear(year)
setMonth(month)
setDate(date)
setHours(hour)
setMinutes(min)
setSeconds(sec)
setMilliseconds	(ms)

setTime(milliseconds) (устанавливает всю дату по миллисекундам с 01.01.1970 UTC)


Автоисправление - это свойство объекта Date, которое поправляет неправильную запись даты или времени.
Например: 32 января 2013 - это 1 февраля 2013.

Дату и время также можно увеличивать/уменьшать с помощью математики:
date.setDate(date.getDate() + 2);

С помощью строки Date.parse("YYYY-MM-DDTHH:mm:ss.sssZ") - разбирает строковое представление даты и возвращает количество миллисекунд, прошедших с 1 января 1970 года 00:00:00 по UTC.

Где YYYY - год, MM - месяц, DD - дата, T - надо ставить между датой и часами, HH - часы, mm - минуты, ss - секунды, .sssZ - милисекунды (между секундами и милисекундами надо ставить "." и после милисекунд надо ставить большую букву Z).

Пример: let date = Date.parse("2022-00-11T20:40:50.200Z");


Date.now() - также как и Date.parse("YYYY-MM-DDTHH:mm:ss.sssZ") разбирает строковое представление даты и возвращает количество миллисекунд, прошедших с 1 января 1970 года 00:00:00 до сейчаснего момента по UTC.	 

Timestamp - это дата, записаная в число из милисикунд.




bind(), call(), apply().

bind() - указивает: на какой объект ссылатся, если в функции есть контекст this.

function.bind(объект, на который ссылаемся , дополнительные параметры, которых нет в этом объекте)
НО ТАК-КАК bind() НЕ ВЫЗЫВАЕТ ФУНКЦИЮ, А ПРОСТО ССЫЛАЕТСЯ НА КАКОЙ-ТО ОБЪЕКТ, ТО ФУНКЦИЯ НЕ ВЫЗОВЕТСЯ И ЕЕ НАДО ВЫЗИВАТЬ ОТДЕЛЬНЫМИ СКОБКАМИ bind()().

Пример: let obj = {name:"Dima", func() {console.log(this.name + " " + this)}} 
	let obj2 = {name:"Oleg", func2: func} //Oleg obj2 - потому-что ну уточналась: что такое this и по этому это будет obj2, так-как он на объекте obj2.
	let obj3 = {name ="Alex", func3: func.bind(obj)()} //Dima obj - потому-что уточнили что такое this: это obj.



call() - тоже самое, что и bind(), только его не надо вызывать еще одними скобками.

Пример: let obj = {age:15; func() {console.log(this.age + " " + this)}}.
	let obj2 = {age:20; func2: func.call(obj)} //15 obj.



apply() - тоже самое, что и call(), но дополнительрые параметры находятся в общем массиве, тоесть мы можем добавить только два параметра в скобках: объект, на который мы ссылаемся и массив, в котором хронятся все дополнительные параметры.

Пример: let obj = {color:"red"; func(this.color) {console.log(this.color + " " + this)}}.
	let obj2 = {color:"yellow"; func2: func.call(obj, ["green", ...])} //obj green.




Режим отладки(Дебаг) (В браузере Edge):

Чтоб открыть режим отладки надо:
1) Открыть папку "Источники".
2) Нажимаем слева на квадратик со стрелочкой.
3) Выбираем нужную папку.
   (Также можно нажать на сочетание клавишь Ctrl+p и выбрать от туда нужную папку).

Если нажать на номер строки в коде, то на ней поставится брэйк поинт(break point), если на брэйк поинт нажать еще раз, то он удалится.
  (Если на каком-то элементе есть брэйк поинт и перезагрузить сайт, то откроится режим отладки, также будут доступны некоторые опции(находятся справа)).

Интерфейс состоит из трёх зон:

1) В зоне File Navigator (панель для навигации файлов) показаны файлы HTML, JavaScript, CSS.
2) Зона Code Editor (редактор кода) показывает исходный код.
3) Зона JavaScript Debugging (панель отладки JavaScript) отведена для отладки.

Зона, отведенная для отладки делится на несколько секторов:
1) Контрольные значения (Можно дабавить какие-то существующие переменные и посмотреть их значения).
2) Точки останова (Содержит в себе все брэйк поитни).
3) Область (Показивает все переменные и их значения).
4) Стек вызовов(показывает цепочку вложенных вызовов).
5) И другие менее важные.	


Опции:
Первая опция - позволяет продолжить выполнение.
Вторая опция - позволяет выполнить следующую команду, но не заходя внутрь функции.
Третия опция - Это похоже на пятую опцию.
Четвертая опция - позволяет продолжить выполнение до завершения текущей функции.
Пятая опция - позволяет выполнить следующую команду.
Шестая опция - позволяет активировать/деактивировать все точки останова.


Также если навести в режиме отладки в коде на какой-то элемент, то под элементом выведится информация про него.




Сборка мусора:

Объекта хронятся в памяти, пока они достижимы(те, которые доступны или те, которые используются).
Сборка мусора выполняется автоматически. Мы не можем ускорить или предотвратить её.
Если объект не доступен, то он удаляется.

Значения, которые не могут быть удалины: Выполняемая в данный момент функция, её локальные переменные и параметры; глобальные переменные (такие значение называются "корневые значения").
Любое другое значение считается достижимым, если оно доступно из корневого значение по ссылке или по цепочке ссылок.

Тоесть если будет удален объект, то и все его свойства и методы будут удалены:
	let obj = {name: "Dima", age: 15}; //Создаем объект obj с свойствами name и age и их значениями соответствено "Dima" и 15.
	obj = null; //Объект obj = пустому множеству(теперь obj - это ничего) и изза этого его свойства name и age будут удалены.

Чтоб удалить какие-то ссылки нужно использовать delete:

delete obj.name; //Свойство name у объекта obj - удалено.
console.log(obj); // {age: 15}	




Map, Set WeakMap, WeakSet

Массив нужен для хранения упорядоченных колекций.
Объект нужен для хранения именных колекций (Есть имя(ключ), которое всегда типа данных - строка, и есть его значение - всегда любой тип данных).
А Map – это коллекция ключ/значение, как и Object. Но основное отличие в том, что Map позволяет использовать ключи любого типа.

Создание мэпа: let map = new Map();

Также при создании мэпа можно указать ключи и их значения с помощью массивов: let map = new Map([["name","Dima"],["age",15]]);


У Map есть такие свойства/методы:

map.set(kay, value); - Устанавливает ключ и дает ему значение(Ключем и значением может быть любой тип данных).
map.get(key); - Получает значение по ключу.
map.has(kay); - Проверяет: есть ли в колекции ключ, который мы ввели в скобки (возвращает true/false).
map.delete(key); - Удаляет ключ и его значение, к которому мы обратились в скобках.
map.clear(); - Удаляет всю колекцию.
map.size; - Возвращает текущее количество элементов в колекции.

map.keys() – возвращает все ключи мэпа.
map.values() – возвращает все значения мэпа.
map.entries() – возвращает объект по парам вида [ключ, значение].

Три предыдущих часто используются для перебора мэпа по его ключам, значениям, или по тому и тому одновременно.

Пример: for(let kays of map.kays()) {...какой-то код...};


Метод Array.from() создаёт новый массив из мэпа.

Пример:
	let a = new Map([["name", "Dima"],["age", 15]]); //Создаем мэп с ключами name и age и их значениями соответстево Dima и 15.
	let b = Array.form(a); // Создаем новую переменную-массив от мэпа a.


Есть метод Object.fromEntries(obj), который делает противоположное: получив массив пар вида [ключ, значение], он создаёт из них объект:
	let a = new Map([["name","Dima"],["age",15]]); //Создаем мэп со свойством name и age и их значениями соответствено Dima и 15.
	let b = Object.fromEntries(a) //Создаем объект b от мэпа a.


Если у нас уже есть обычный объект, и мы хотели бы создать Map из него, то поможет встроенный метод Object.entries(obj), который получает объект и возвращает массив пар ключ-значение для него, как раз в этом формате.
Так что мы можем создать Map из обычного объекта следующим образом:
	let a = {name:"Dima", age:15}; //Создаем объект со свойством name и age и их значениями соответствено Dima и 15.
	let b = new Map(Object.entries(a)); //Создаем мэп b от объекта a.



Объект Set – это особый вид коллекции: «множество» значений (без ключей), где каждое значение может появляться только один раз(тоесть, если я добавлю одно и тоже значение несколько раз, то оно добавится всего один раз).

Создание сэта: let set = new Set();

Также при создании сэта можно указать значения с помощью массива: let set = new Set([1,2,3]);


У Set также есть свойства/методы:
	
set.add(value) - Добавляет значение(но если оно есть, то ничего не нобавляется).
set.has(value) - Проверяет: есть ли в колекции ключ, который мы ввели в скобки (возвращает true/false).
set.delete(value) - Удаляет значение, к которому мы обратились в скобках.
set.clear() - Удаляет всю колекцию.
set.size - Возвращает количество значений в колекции.


WeakMap	

Отличие WeakMap от Map в том, что ключи в WeakMap должны быть объектами, а не примитивными значениями.

Создание WeakMap:	

let weakMap = new WeakMap(obj, "value");


В WeakMap присутствуют только следующие методы:

weakMap.get(key);
weakMap.set(key, value);
weakMap.has(key);
weakMap.delet(key);


WeakSet()

Отличие WeakSet от Set в том, что ключи в WeakSet должны быть объектами, а не примитивными значениями(как и в WeakMap).

Создания WeakSet:

let weakSet = new WeakSet();


В WeakMap присутствуют только следуйщие методы:

weakSet.add(obj);
weakSet.has(obj);
weakSet.delete(obj);




Промисы

Промис - это такой объект, который обрабатывает результаты асинхронных операций внутри себя и возврощает результат.

Создание промиса - let prom = new Promise(function(resolve, reject) {
	Асинхронный код
})


Promise может находиться в трёх состояниях:

ожидание (pending): начальное состояние, не исполнен и не отклонён.
исполнено (fulfilled): операция завершена успешно.
отклонено (rejected): операция завершена с ошибкой.	

Когда мы пишем внутри промиса resolve(переменные), то это значит, что промис должен завершить свое выполнение успешно (переменные внутри resolve - это какие-то данные с асинхронной операции, которые будут передаватся в then).
А когда мы пишем внутри промиса reject(переменные) - промис должен завершить свое выполнение с ошибкой (переменные внутри reject - это какие-то данные с асинхронной операции, которые будут переданы в catch).


prom.then(function(переменные с resolve){ код }) - Вызывается после того, как промис закончился успешно (переменные внутри функции у then - это данные, которые были переданы с resolve, (их можно переименовать)).


Внутри then можно создавать новые промисы.


Из then можно сделать ципочки:

prom.then(function() {
console.log(`Hello_1`) //После выполнения resolve() в консоль будет выведена строка `Hello_1`
}).then(function() {
console.log(`Hello_2`) //После того, как будет сработан первый then, будет выполнятся второй (`Hello_2`)
}).then(function() {
console.log(`Hello_3`) //Когда выполнится второй then сработает третий и будет вывелено `Hello_3`
})

(И такую ципочку можно еще продолжить)


prom.catch(function(переменные с reject) { код }) - Вызываеться тогда, когда промис закончился с ошибкой (переменные внутри функции у catch - это данные, которые были передены с reject, (их можно переименовать)).	

prom.finally(function(переменные с resolve или reject){ код }) - Вызывается несмотря на результат промиса (с ошибкой или без ошибки все равно вызовется).


Promise.all([prom1,prom2]) - Promise.all - Ждет когда выполнятся все промисы в массиве внутри Promise.all, а метод далее метод then выводит в консоль строку `All promise`
.then(function() { console.log(`All promise`) })


Promise.race([prom1,prom2]) - Promise.race - Ждет когда выполнится первый промис (тот, который выполнится быстрее всех) внутри Promise.race, а далее метод then выводит в консоль строку `Race promise`
.then(function() { console.log(`Race promise`) })

Promise.resolve(`ok`) - промис, который по умолчанию успешно выполняется.
Promise.reject(`error`) - промис, который по умолчанию выполняется с ошибкой.




async и await


//async

Ключевое слово async перед функцией гарантирует то, что эта функция в любом случае вернёт промис:

async function f() {
	retunr ("hello");
}  // функция вернет промис


У функции, перед которой стоит слово async есть методы then, catch, finally также, как и у промисов:

f().then(function() {console.log("Ok")})

f().catch(function() {console.log("Error")})

f().finally(function() {console.log("Finally")})



//await

await можно использовать только внутри async-функции.


Ключевое слово await заставит интерпретатор JavaScript ждать до тех пор, пока промис справа от await не выполнится. После чего оно вернёт его результат(То, что написано в resolve), и выполнение кода продолжится:

async function f() {
	let prom = new Promise(function(resolve, reject) {setTimeout(function() {resolve("ok")}, 2000)})
	await prom; //Будет ждать до тех пор, пока не выполнится промис prom(тоесть 2 секунды), потом вернет содержимое промиса и продожит выполнять код дальше.

	alert("hello"); //Выведет hello.
}

f() //Есле же await prom не было б прописанxо, то hello вывелось бы моментально, не дожедаясь выполнения промиса prom.

await - это почти тоже самое, что и then.


// метод throw

	
throw возвращает что-то при ошибке:

async function f(){
	throw "There is error"; 	// создастся ошибка и выведется в консоль There is error.
}




BOM (Browser Object Model | Объектная модель браузера)
BOM включает в себя: window, location, history, navigation и screen.


window - самый главный объект в браузере, который является корнем иерархии всех объектов доступных веб-разработчику в сценариях JavaScript.


location – объект, который отвечает за адресную строку браузера. Данный объект содержит свойства и методы, которые позволяют:
получить текущий адрес страницы браузера, перейти по указанному URL, перезагрузить страницу и т.п.


history – объект, который позволяет получить историю переходов пользователя по ссылкам в пределах одного окна (вкладки) браузера. 


navigator – информационный объект, с помощью которого вы можете получить различные данные, содержащиеся в браузере:
версию, название, используемую локаль, доступные права, подключенные плагины.


screen – объект, который предоставляет информацию об экране пользователя: разрешение экрана, максимальную ширину и высоту, которую может иметь окно браузера, глубина цвета и т.д.


location:

assign() - Загружает новый документ в текущее окно (вкладку) браузера.
reload() - Перезагружает документ с текущем URL-адресом. Может принимать один аргумент булева типа: true - перезагрузка страницы с сервера, false - перезагрузка страницы из кэша браузера.

href - Задает или возвращает полный URL-адрес документа.
hostname - Задает или возвращает имя хоста(домен) из URL-адреса.
hash - Задает или получает часть URL-адреса, следующую за знаком #.
port - Содержит строку с портом.
protocol - Задает или получает протокол (протокал - это //https: , file: и т.д.).
origin - Возвращает строку, содержащую URL-адрес, включающий протокол, домен и порт. (домен это - www.google.com)
pathname - Строка, содержащая имя файла или путь к текущему файлу от корневой папки.
search	Задает или возвращает часть URL-адреса, следующую за знаком вопроса (?), включая сам знак вопроса.


	
history:

history.back() - То же самое, что нажатие на кнопку браузера "Назад".
history.forward() - То же самое, что нажатие на кнопку браузера "Вперед".
history.go() - Можно задать в скобках переход самостоятельно. 



navigator :

appCodeName – Кодовое имя браузера.
appName – Имя браузера.
appVersion — Версия браузера.
cookieEnabled - Позволяет определить включены ли cookie в браузере.
javaEnabled() – Позволяет узнать, включён ли в браузере Java.
geolocation - Используется для определения местоположения пользователя.
language - Язык браузера.
onLine - Имеет значение true или false в зависимости от того находиться ли браузер в сети или нет.
platform - Название платформы, для которой скомпилирован браузер.
product - Название движка браузера.
userAgent - Возвращает заголовок user agent, который браузер посылает на сервер. (Выводит appCodeName и appVersion)


screen:

width – Ширина экрана в пикселях.
height – Высота экрана в пикселях.
availWidth – Доступная ширина экрана.
availHeight – Доступная высота экрана (например, в Windows, эта высота равна общей высоте из которой нужно вычесть высоту панели задач).
availLeft – x-координата первого доступного пикселя.	
availTop – y-координата первого доступного пикселя.
pixelDepth – Глубину цвета на пиксель экрана в битах.
orientation – Ориентация экрана.




DOM (Document Object Model - Объектная модель документа).

document -  это точка входа в DOM.

document.documentElement - <html> </html>.
document.head - <head> </head>.
document.body - <body> </body>.
...


.firstChild - Первый дочерний узел элемента(Может быть текстовый узел).
.firstElementChild - Первый дочерний элемент элемента(Только тег).

.lastChild - Последний дочерний узел элемента(Может быть текстовый узел).
.lastElementChild - Последний дочерний элемент элемента(Только тег).


.childNodes - находит всю колекцию детей объекта.
.children - тоже самое, что и .childNodes, но выводит только теги, без текстовых узлов.


.parentNode - выводит родительский узел эдемента (Может быть текстовый узел).
.parentElement - выводит родительский элемент эдемента (Только тег).


.hasChildNodes() - проверяет: есть ли у объекта дачерние узлы (выводит true или false).


text - это текстовый узел (перенос строки).


.previousSibling - выводит предыдущий узел (Может быть текстовый узел).		
.previousElementSibling - выводит предыдущий элемент (Только тег).

.nextSibling - выводит следуйщий узел (Может быть текстовый узел).
.nextElementSibling - выводит следуйщий элемент (Только тег).

.querySelectorAll("TagName" ".class" "#id" "[Атрибут]") [номер] - находит все элементы, которые удовлетворяют тому, что находится в круглых скобках, но также в конце можно дописать в квадратных скобках номер узла.


.querySelector("TagName" ".class" "#id" "[Атрибут]") - находит первый объект, который удовлетворяет тому, что написано в круглых скобках.
	

.getElementById("id") - находит объект по id, указаному в круглых скобках.


.getElementsByTagName("TagName") - находит объекты по имени тега, указаному в круглых скобках.
.getElementsByClassName("class") - находит объекты по классу, указаному в круглых скобках.


Живая колекция - это колекция, которая будет содержать в себе актуальную информацию и после того как дерево DOM изменится.


.closest("TagName" ".class" "#id" "[Атрибут]") - ищет ближайшого предка, который удовлетворяет тому, что написано в круглых скобках (родителя, прарадителя, прапрарадителя...) (Если сам объект удовлетворяет услове, то он вернет себя).


.innerHTML - Получает содержимое объекта (Вместе с тегами).
.outerHTML - Получает и содержимое объекта, и сам объект(Тег)
.textContent - Получает только содержимое объекта(текст), если в содержимом есть теги то они превратятся в просто текст.
.data - Получает текст внутри коментария.


.createElement("TagName") - Создает новый тег.
.createTextNode("Текст") - Создание текстового узла.


Созданые объекты находятся в переменных, и не являются частью документа.


.before(TagName) - Вставляет или переносит какой-то объект перед объектом (Вставляется или переносится тот объект, который ми указали в скобках)  (Вставляют только элементы или текст, а текст с тегами как innerHTML - нет).
.after(TagName) - Вставляет или переносит какой-то объект после объекта (Вставляется или переносится тот объект, который ми указали в скобках)  (Вставляют только элементы или текст, а текст с тегами как innerHTML - нет).
.prepend(TagName) - Вставляет или переносит какой-то объект в начало другого объекта (Вставляется или переносится тот объект, который ми указали в скобках)  (Вставляют только элементы или текст, а текст с тегами как innerHTML - нет).
.append(TagName) - Вставляет или переносит какой-то объект в конец другого объекта (Вставляется или переносится тот объект, который ми указали в скобках)  (Вставляют только элементы или текст, а текст с тегами как innerHTML - нет).


.insertAdjacentHTML("Куда имено" "Что имено") - Вставляет строку с HTML тегами относительно какого-то объекта.
.insertAdjacentText("Куда имено" "Что имено") - Вставляет просто текст относительно какого-то объекта.
.insertAdjacentElement("Куда имено" "Что имено") - Вставляет элемент относительно какого-то объекта.


beforebegin - Перед объектом (Куда имено)
afterend - После объекта (Куда имено)
afterbegin - В начало объекта (Куда имено)
beforeand- В конец объекта (Куда имено)


Что имено - Строка, текст, элемент который мы вставляем.


.cloneNode() - Клонирует объект (в скобках надо писать true или false) (Если false, то это неглубокое клонирование, тоесть тег клонируется без текста внутри) (Если true, то это глубокое клонирование, тоесть тег клонируеться с текстом внутри).


.remove() - Удаляет какой-то объект.


.className - Содержит внутри себя все имена классов объекта.


.classList.add("Имя класса") - Добавляет какой-то класс.
.classList.remove("Имя класса") - Удаляет какой-то класс.
.classList.toggle("Имя класса") - Добавляет какой-то класс если его нет или удалит если есть.
.classList.contains("Имя класса") - Проверяет наличие класса (true или false).	

 	
.style.CSS-свойство - Добавляет CSS свойства для какого-то тега.


.style.cssText - Можно добавить несколько css свойств зразу, но этот метод полностью перезаписывает все css стили, и если были какие-то свойства до этого, то они пропадут.
.style.cssText = "background-color:red; color:white; width:100px; height:100px;";


Свойство style - Работает только в том случаи, если свойство в атрибуде html.


getComputedStyle(TagName) - Хранит в себе CSS стили объекта (не обязательно, чтоб стили были записаны в атрибуде html).



.hasAttribute("Атрибут") - Проверяет наличие атрибута.
.getAttribute("Атрибут") - Получает атрибут
.setAttribute("Атрибут", "Значение") - Устанавливает атрибут.
.removeAttribute("Атрибут") - Удаляет атрибут.
.attributes – Коллекция всех атрибутов.


В зависимости от своего класса DOM-узлы имеют и другие свойства.
 Например у элементов <input> (HTMLInputElement) есть свойства value, type, у элементов <a> (HTMLAnchorElement) есть href и т.д.
 Большинство стандартных HTML-атрибутов имеют соответствующие свойства DOM.

URL.createObjectURL() - создает URL адресс для того файла, который мы прописали в скобках. Это полезно тогда, когда мы ходим создать URL адрес для картинки, которую мы выбрали в <input type="file"> <input>, чтоб потом этот URL адрес прописать в src у <image> (часто используеться для React проектов)



Размеры, Прокрутка, Координаты.

document.documentElement.clientWidth - Доступная ширина экрана (от края до полосы прокрутки, если она есть).
document.documentElement.clientHeight - Доступная высота экрана (от края до полосы прокрутки, если она есть).


window.innerWidth - Полная ширина окна браузера (вместе с полосой прокрутки). (Отличие от offsetWidth в том что innerWidth выводит ширину окна (то, что попадает на экран), а offsetWidth ширину страницы (даже то, что не попадает на экраны))
window.innerHeight - Полная высота окна браузера (вместе с полосой прокрутки). (Отличие от offsetHeight в том что innerHeight выводит высоту ОКНА (только то, что попадает на экран), а offsetHeight высоту СТРАНИЦЫ (даже то, что не попадает на экраны))


window.pageXOffset - Выводит количество прокрученных пикселей по x-у. (Можно заменить на scrollTop)
window.pageYOffset - Выводит количество прокрученных пикселей по у-у. (Можно заменить на scrollTop)


window.scrollBy(x, y) - Докручивает на какое-то количество пикселей.


window.scrollTo(x, y) - Прокручивает к координатам, указаним в скобках(Не докручивает, а прокручивает!).


window.scrollTo({
   top: y,
   left: x,
   behavior: "smooth" - Даем прокрутке параметр smooth, тоесть переход будет плавным, также есть параметр instant(Неплавно).
})


.scrollIntoView(top) - Прокручивает страницу относительно какого-то объекта, если в скобках записано top то объект будет сверху, а если false - снизу.


.scrollIntoView({
   block: "centre", - Отвечает за вертикальную позицию объекта(Также есть start - вверху, nearest - по умолчанию и end - внизу).
   inline: "nearest", - Отвечает за горизонтальную позицию объекта(Также есть start - слева, nearest - по умолчанию и end - справа).
   behavior: "smooth" - Даем прокрутке параметр smooth, тоесть переход будет плавным, также есть параметр instant(Неплавно).
})



.offsetParent - Ближайший родительский объект, у которого есть CSS свойство position. 


.offsetLeft - Возвращает положение объекта слева относительно родительского объекта(offsetParent).
.offsetTop -  Возвращает положение объекта сверху относительно родительского объекта(offsetParent).

.offsetWidth - Возвращает ширину объекта.
.ofsetHight - Возвращает высоту объекта.


.clientTop - Возвращает верхний отступ внутрений части элемента от внешней(border и полоса прокрутки).
.clientLeft - Возвращает левый отступ внутрений части элемента от внешней(border и полоса прокрутки).

.clientWidth - Возвращает ширину объекта не учитывая border и полосу прокрутки.
.clientHeight - Возвращает высоту объекта не учитывая border и полосу прокрутки.


.scrollTop - Возвращает прокрученую часть контента по вертикали(ту, которую уже прочитали).
.scrollLeft - Возвращает прокрученую часть контента по горизонтали(ту, которую уже прочители).

.scrollWidth - Возвращает весь контент объекта по ширене(и ту часть, которую мы не видим).
.scrollHeight - Возвращает весь контент объекта по высоте(и ту часть, которую мы не видим).



.getBoundingClientRect() - Возвращает координаты объекта.
(left - от края до начала объекта по горизонтали, top - от края до начала объекта по верткали, width - ширина объекта, height - высота объекта, right = left + width, bottom = top + height).


.elementFromPoint(x, y) - Выводит объект, который находится на координатах, указаныйх в скобках.


События
		
атрибут onclick="Что будет делаться" - При нажатии что-то будет делаться(пишим в HTML).

.onclick = function - При нажатии на кнопку что-то будет делаться(пишим в JS) (Отрабатывает только последние событие).

.addEventListener("Событие", function) - как onclick, но с помощью него можно отрабатывать несколько событий сразу.

.removeEventListener("Событие", function) - Удаляет событие.


function(e) - Объект события (В объект события браузер записывает делтали события).

e.type - Возвращает тип события.

e.target - Возвращает объект, на котором сработало событие.

e.currentTarget - Возвращает объект, на котором весит событие.

e.clientX - Возвращает координаты по x-у, на которых было совершено событие.

e.clientY - Возвращает координаты по y-у, на которых было совершено событие.

e.which - Выводит номер кнопки(1 - Левая, 2 - Колесо, 3 - Правая).


Погружение - Когда событие только возникло, оно начинает двигаться по DOM-дереву, начиная от корневого узла, до самого глубокого, на котором произошло событие

Всплытие - Когда на элементе происходит событие, обработчики сначала срабатывают на нём, потом на его родителе, затем выше и так далее, вверх по цепочке предков. 
e.stopPropagation() - Блокирует всплытие (совершение событие других объектов(тех, которые были под объектом, который мы нажала(родительских))).

Сначало происходит погружение, потом событие доходит до самого глубоко-вложенного элемента, а потом происходит всплытие.


Делегирование - Вместо того чтоб подключать одно и тот же событие каждому элементу, можно подключить одно событие общему предку и потом проверить исходные элемент (e.target). 

function fun(event)
{
   if(event.target.closest("button")){
	код
   };
}

div.addEventListener("click", fun);


Действия браузера по умолчанию(Переход на другой сайт при нажатии на ссылку, Выделение мишью текст и т.д.)
e.preventDefault() - Отменяет выполнение стандартное(По умолчанию) действие браузера.


Параметры события 


"capture": true/false - Выполняет при погружении события.
"once": true/false - Указывает, что обработчик должен быть вызван не более одного раза после добавления.
"passive": true/false - Указивает, что обработчик никогда не вызовет preventDefault().

Пример: addEventListener("click", function, {"once": true})


События мыши:
click - При ннажании.
dblclick - При двойном нажатии.
mousedown - При нажатии на кнопку пиши.
mouseup - При поднятии кнопки миши.
mouseover - При наведении курсора на объект.
mouseout - При отводе курсора от объекта.
mouseenter - Тоже самое что и mouseover, но при переходе на дочерний объект всплыие не преисходит.
mouseleave - Тоже самое что и mouseout, но при переходе от дочернего объекта всплыие не преисходит.
mousemove - При движении курсора.
contextmenu - При нажатии не основной кнопки мыши(Не Левой, а правой).
		

События клавиатуры:
keydown	 - При нажатии кнопки.
keyup - При отпускании кнопки. 

e.code - Выводит клавишу капсом на английской клавиатуре.
e.key - Выводит ту клавишу, которую я нажал, не смотря на язык или регистр.

События скролла:
scroll - Сработает при прокрутке страницы.

События загрузки страницы:
document.DOMContentLoaded - При загрузке всех HTML элементов, не смотря на внешние ресурсы(картинки, css, js и т.д.).
window.load - При загрузке всех HTML элементов и внешних ресурсов(картинки, css, js и т.д.).
window.unload - При покидании пользоватилем страницу.

document.readyState - Возвращает состояние страницы.
(loading - документ загружается, interactive - документ полностью прочитан, complete - документ полностью прочитан и все внешние ресурсы были загружены).


Формы

document.forms - Выводит колекцию всех форм(живую колекцию в отличии от querySelectorAll()).

document.forms[номер] - Выводит определенную форму по ключу(номеру в скобках).

var form1 document.forms.name  - Выводит определенную форму по атрибуту name(пишим в HTML).

form1.elements - Выводит список всех элементов формы.

var inpt = form1.name или form1[index]- Выводит элемент формы по атрибуту name(пишим в HTML) или его индексу.

inpt.form - Выводит форму-родителя элемента(в нашем случии inpt).

inpt.value -  Выводит значение поля ввода(Если оно текстовое), также можно с помощью value задать значение.
inpt.checked - Выводит значение поля ввода(Если оно булловское), также можно с помощью checked задать значение.
input.files - Выводит все файлы, которые были выбраны(Если поле ввода с type="file").

select.options - Выводит колекцию всех опций селектора.
select.value - Выводит текущий value(написано в атрибуде HTML) выбраной в данный момент опции селектора, также можно с помощью value задать значение.
select.selectedIndex - Выведит номер выбраной опции селектора.
select.options[номер].text - Выводит текст выбраной опции.

var option = new Option("text", value, defaultSelected(true/false), selected(true/false)) - Можна добавлять опции селектору.
select.append(option);

Элемент получает фокус, когда на него кликают(focus).
Момент потери фокуса возникает при нажатии куда-либо, но не на элемент(blur).

.addEventListener("focus", function) - При фокусе пусть происходит function.
.addEventListener("blur", function) - При потере фокуса пусть происходит function.

input.focus() - Установить фокус.
input.blur() - Снять фокус.

При событии focus всплытие не происходит, чтоб происходило всплытие надо использовать событие focusin.

При событии blur всплытие не происходит, чтоб происходило всплытие надо использовать событие focusout.

document.activeElement - Выводит текущий элемент с фокусом.

tabindex - атрибут, устанавливающий порядок перехода между элементами с помощью клавиши Tab (Тоесть сначали фокус будет на элементе 1 потом на 2, 3...).

Если tabindex = 0, то переход к элементам происходит после всех «нумерованных» элементов в том порядке, как они указаны в коде. 

Если tabindex = -1, то клавиша Tab проигнорирует такой элемент.

Событие change происходит после окончание сробатывания элемента.

Событие input срабатывает каждый раз при изменении значения поля.

Событие copy срабатывает при копирывании значения в поле.

Событие paste срабатывает при копировании значения в поле.

Событие cut срабатывает при вырезании значения из поля.
	 
Событие submit срабатывает при отправке формы (по нажатию на Enter).


Модули

Если вы попытаетесь открыть веб-страницу локально, через протокол file://, вы обнаружите, что директивы import/export не работают.
Для тестирования модулей используйте локальный веб-сервер, например, static-server или используйте возможности «живого сервера» вашего редактора

Когда код очень большой его можно разделить на часть - модули.

Модуль - файл со скриптом.

Чтоб js скрипт стал модулем нужно добавить тегу script атрибут type="module".


Для того, чтоб что-то экспортировать(передать что-то) надо использовать export что-то  (Экспортировать можно разные типы данных: число, строка, массив, функция, объект...).
Пример(этот файл называется hello.js):
	let hello = "hello!"; //Создали переменную hello.
	export hello; //Экспартируем переменную hello.


Для того, чтоб что-то импортировать(получить что-то из другого файла, но также надо чтоб это что-то было экспортировано ранее) надо использовать  import что-то from "./имя файла"  (Импортировать можно разные типы данных: число, строка, массив, функция, объект...).
Пример(этот файл называется main.js):
	import hello from "./hello.js"; //Импортируе переменную hello из файла hello.js.


Также можно экспортировать несколько элементов сразу с помощью export {}:
	export {что-то1, что-то2, ...};

Импортировать можно также по несколько элементов сразу:
	import {что-то1, что-то2, ...} from "./имя файла";

Для легкости писания кода лучше всега прописывать что-то в фигурных скобках {}, даже если это один элемент.


Чтоб импортировать что-то под другим именем(мы импортируем какой-то элемент и переименовываем его, в основном для того чтоб сократить название) надо после имени элемента прописать as и потом имя, на которое переименновываем:
	import {hello as hi} from "./hello.js"; //Импортировали переменную hello из файла hello.js и переименовали ее как hi.

Аналогично с экспортом:
	export {hello as hi}; //Экспортируем переменную hello как hi.  


Экспорт по умолчанию(export default) позволяет экспортировать элемент не указывая имени, но также экспорт по умолчанию должен экспортировать только один элемент:
	export default [1,2,3]; //Нет имени, экспортирует только один массив.


Чтоб импортировать все именнованые экспорты в один объект надо после import прописать * и потом задать этому всему другое имя с помощью as.
Припер:
	import * as all from "./имя файла"; //Мы экспортировали все именнованые экспорты из какого-то файла в один объект all.

Чтоб обратится к какому-то экспортированому элементу из объекта all надо прописать: all.то, к чему хотим обратиться;
Пример: console.log(all.name); //Обратились к экспортированому элементу name через общий объект all.


Сортировка массива

function sorting(a){
  for(let n = 0; n < a.length; n++){
    for(let i = 1; i < a.length - n; i++){
      if(a[i-1] > a[i]){
        let j = a[i];
        a[i] = a[i-1];
        a[i-1] = j;
      }
      console.log(a);
    }
  }
}

Git:

Чтоб открыть терминал, в котором будем писать код, нужно в поиске написать Git Bash и открыть
Но можно сделать все гараздо проще: нажать на нужную папку ПКМ и выбрать "Git Bash Here"
А также можно писать в терминале VS code



git --version - выводит версию git
git --help - выводит возможные команды
clear - очищает весь терминал



dir - показывает список папок и файлов в данной дериктории

Директория - это тот же самый термин, что и "папка". Это структура для хранения файлов и поддиректорий.
Поддиректория - это директория внутри директории

cd <имя дериктории> - переходит в выбраную директорию (Чтоб перейти назад нужно написать .. вместо имени директории)

git init - инициализирует новый локальный репозиторий -  создает поддиректорию .git внутри нашей директории. В этой поддиректории хранятся все необходимые файлы и структуры данных, которые Git использует для отслеживания изменений, управления версиями и хранения истории проекта.
После этого вся наша директория, включая поддиректорию .git, образует локальный репозиторий, в котором Git отслеживает изменения в ваших файлах и предоставляет вам инструменты для работы с версиями вашего проекта.

Репозиторий - это весь набор файлов и директорий, включая вашу текущую директорию и поддиректорию .git, а также это вся история изменений проекта. Это целостная единица для отслеживания изменений и управления версиями.
В простых словах, репозиторий представляет собой папку, в которой Git хранит всю информацию о вашем проекте

Есть локальный и удаленный репозиторий:

Локальный репозиторий - это ваш репозиторий, который находится только на вашем компьютере.

Удаленный репозиторий - это репозиторий, который расположен на удаленном сервере (например, на GitHub). Это место, куда вы можете загружать свои изменения или откуда вы можете получать изменения других разработчиков.

После инициализации мы можем использовать другие команды Git, такие как git add, git commit, и так далее, чтобы управлять изменениями в вашем проекте. Это и есть инструменты, которые предоставляет Git для работы с версиями нашего проекта после его инициализиции.



git status - выясняет статус(состояние) проекта (то, что происходит в проекте: все его ветки, коммиты и т.д.)

Когда мы пропишим команду git status, мы получим сообщение:

On branch master - пишит: на какой ветке мы находимся

No commits yet - пишит: коммитов нет

Untracked files: - пишит: файлы, за которыми git не следит
  (use "git add <file>..." to include in what will be committ - пишит: чтоб за ним следить, нужно прописать команду git add имя файла
        index.html  - пишит: список файлов, за которыми git не следит (в нашем случаи это только index.html)



Индекс в Git - это промежуточная зона, где вы подготавливаете изменения перед коммитом. 



Когда мы создаем что-либо в нашем репозитории, он меняеться и его нужно фиксировать в индексе

git add  <имя файла> - (угловые скобки писать не надо) команда, которая добавляет файл(который мы указали) в индекс

После того, как мы напишем команду git add имя файла, а после напишим git status, мы увидим такое сообщение:

On branch master - пишит: на какой ветке мы находимся

No commits yet - пишит: коммитов нет

Changes to be committed: - пишит: есть изменения, за которыми git следит
  (use "git rm --cached <file>..." to unstage) - тут нам  говорят, что с помощью команды  git rm --cached имя файла мы можем перестать следить за файлом, который был добавлен
        new file:   index.html - в репозиторий добавлен новый файл "index.html", за которым git теперь следит

Если мы хотим добавить все файлы, за которыми мы не следим, нужно вместо имени файла прописать . (git add .)

git rm --cached <имя файла> - эта команда делает так, чтоб git перестовал следить за файлом, который мы написали (в нашем примере, если после этого ввести команду git status, мы увидим сообщение, которое было до git add имя файла)

Когда мы как-то изменяем файлы проекта, гит перестает следить за изменеными файлами и для этого нам нужно их каждый раз фиксировать с помощью git add


Если у нас в проекте есть файлы, которые не должны быть в репозитории, то их нужно заигнорить

Чтоб такие файлы заигнорить, нужно создать файл с названием .gitignore
А потом в этот файл нужно написать полное название всех тех файлов, которые хотим нужно заигнорить
Ну а сам файл .gitignore нужно добавить в репозиторий (git add .gitignore)


git mv <старое имя файла> <новое имя файла> - переименовывает файл 


Если в дальнейшем что-то в проекте пойдет не так, нам надо будеть как-то вернуться к предыдущему сохранениею репозитория, а чтоб сохранения были нужно коммитить проект (коммитить - сохранить текущее состояние реопзитоия)

Коммит - это действие записи изменений в репозитории. Каждый коммит фиксирует определенный набор изменений, создавая точку сохранения в истории проекта.
Коммиты делаются для отслеживания изменений, внесенных в проект со временем

git commit -m "Сообщение коммита" - это создает коммит репозитория (сохранение - репозитория), -m - значит message, а в кавычках сообщение(комментарий) коммита, чтоб другим людям было понято: зачем этот коммит нужен

В дальнейшем к коммтам можно возвращатся


НО, ЧТОБ КОММИТ РАБОТАЛ НУЖНО НАСТРОИТЬ ИНФОРМАЦИЮ ОБ АВТОРЕ В Git!

git config user.name "Your Name" - указываем имя автора только в текущем репозитории
git config user.email "your-email@example.com" - указываем почту автора только в текущем репозитории

Но если мы напишиим так, как показано сверху, то это настроит информацию об авторе в Git только в текущей репозитории!

Чтоб настроит информацию об авторе в Git глобально (для всех репозиториев), нужно указать флаг --global после config:

git config --global user.name "Your Name" - указываем имя автора
git config --global user.email "your-email@example.com" - указываем почту автора

Если все верно, то будет такое сообщение:

[master (root-commit) 905560a] MESSAGE - добавлен коммит в ветку master с комментарием MESSAGE и с хешом 905560a
 1 files changed, 10 insertions(+) - добавлен один файл
 create mode номер файл - файл который добавлен с номером


Чтоб перейти на какой-то коммит, нужно написать git checkout хеш коммита


Чтоб посмотреть изменения с момента предыдущего коммита нужно написать: git diff

Чтоб посмотреть историю коммитов в данной ветке, нужно прописать комманду git log
git log --author="Имя автора" - фильтрирует коммиты по автору.

git show хеш коммита(не мение первых 4 символов) - выводит информацию коммита, хеш которого мы указали
Если хеш коммита не указывать, то выведиться информация про текущий коммит (git show - выводит информацию про текущий коммит)

Флаг - это дополнительные аргументы, которые можно передавать в команды для настройки их поведения.
Флаги обычно указываются после имени команды и могут изменять различные аспекты выполнения команды.
Примеры флагов в git командах:
			 git rm --cached <имя файла> (тут флаг - это --cached),
			 git commit -m "Сообщение коммита" (тут флаг - это -m),
			 git config --global user.name "Your Name" (тут флаг - это --global)

Ветка - это метка, указывающуя на конкретную версию проекта

Чтоб узнать список веток в проекте, нужно написать git branch
Ветка, на которой мы находимся будет зеленого цвета

Чтоб создать новую ветку, нужно написать git branch <имя ветки>
Чтоб удалить ветку из локального репозитория, нужно написать: git branch -d <имя ветки>
А чтоб удалить ветку из удаленного репозитория, нужно написать: git push origin --delete <имя ветки>
Чтою переименовать ветку на которой сейчас находимся, нужно написать: git branch -m <новое имя ветка>

Чтоб перейти на какую-то ветку, нужно написать git checkout  <имя ветки>
То есть с помощью git checkout можно переходить как по коммитам, так и по веткам

Чтоб создать новую ветку и сразуже перейти на нее, нужно написать git checkout -b <имя ветки>

У каждой ветки есть свои файлы. У одной ветке не будет тех файлов, которые есть у других и наоборот

Мы можем совмещать ветки (передавать данные из какой-то ветки в ту, в которой мы находимся сейчас)

Слияние - совмещение веток

Чтоб совместить ветку, в которой мы находимся и какую-то другую ветку нужно сделать так: git merge <имя другой ветки> (передаем в ветку, в которой сейчас находимся все данные из ветка, которую указали)



Git Hub:

git remote -v - выводит все удаленные репозитории

git remote add origin URL - связывает локальный репозиторий с удаленным в GitHub по URL

После добавления удаленного репозитория с именем origin, вы сможете использовать origin в командах, связанных с удаленными операциями, такими как git push и git pull.

git clone URL - клонирует удаленный репозиторий из GitHub по URL, и добавляет все его данные в директорию, в которой я сейчас нахожусь (создает локальную копию этого удаленного репозитория)

git push хеш ветка (git push origin master) - добавляет в удаленный репозиторий, то что прописано в локальном

Также с помощью git push можно добавить новую ветку в удаленный репозиторий: git push хеш имя ветки, которую хотип добавить (git push origin newBranch)
А еще с помощью git push можно удалить ветку из удаленного репозитория, нужно написать: git push origin --delete <имя ветки>

Чтоб удалить ветку из удаленного репозитория нужно написать: git push origin --delete <имя ветки>

origin - это тот репозиторий, к которому мы привязывались с помощью git remote (чтоб не писать имя репозитория, можно написать origin)

Если над проектом работает несколько людей, то когда они закончат писать в локальном репозитории, они добавят это код в удаленный, но другие разработчики не будуь видеть изменения в своем локальном репозитории.
Чтоб им был виден это код, они нужно прописать git pull

git pull хеш ветка (git pull origin master) - добавляет в локальный репозиторий все последние изменения из удаленного



Скорочено:


Git:
git --version - пишет версию git
git --help - пишет самые используемые команды
clear - очищает консоль

dir - пишет все файлы в текущей директории
cd <имя директории> - переходит в выбранную директорию

git init - инициализирует выбранную директорию
git status - пишет состояние индекса

git add  <имя файла> - добавляет файл в индекс
git rm --cached <имя файла> - удаляет файл из индекса

git mv <старое имя файла> <новое имя файла> - переименовывает файл

git commit -m "Сообщение коммита" - создает коммит(сохранение)

git config user.name "Your Name" - указываем имя автора только в текущем репозитории
git config user.email "your-email@example.com" - указываем почту автора только в текущем репозитории

git config --global user.name "Your Name" - указываем имя автора только во всех репозиториях
git config --global user.email "your-email@example.com" - указываем почту автора только во всех репозиториях

git log - выводит историю коммитов в данной ветке
git log --author="Имя автора" - фильтрирует коммиты по автору

git diff - пишет изменения с момента предыдущего коммита

git show хеш коммита(не менее первых 4 символов) - выводит информацию коммита, хеш которого мы указали

git checkout хеш коммита - переходит на какой-то коммит по хешу

git branch - выводит все ветки директории
git branch <имя ветки> - создает новую ветку
git branch -m <старое имя ветка> <новое имя ветка> - переименовывает ветку
git branch -d <имя ветки> - удаляет ветку по имени из локального репозиторя
git push origin --delete <имя ветки> - удаляет ветку по имени из удаленного репозиторя

git checkout  <имя ветки> - переходит на какую-то ветку по имени
git checkout -b <имя ветки> - создает и переходит на эту новую ветку

git merge <имя другой ветки> - совместить ветку, в которой мы находимся и ветку, имя которой мы написали


для GitHub:

git remote -v - выводит все удаленные репозитории

git remote add origin URL- связывает локальный репозиторий с удаленным в GitHub по URL

git clone URL - клонирует удаленный репозиторий в локальный

git push хеш ветка (git push origin master) - добавляет изменения из локального репозиторию в удаленный
git push origin --delete <имя ветки> - удаляет ветку из удаленного репозитория

git pull хеш ветка (git pull origin master) - добавляет в локальный репозиторий все файлы из удаленного
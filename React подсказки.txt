Подключение React
JSX
Компоненты
Состояния
props
Условия в JSX
Добавление стилей
Добавление картинки
Что такое хук
Хук useState
Virtual DOM
Создание однотипных компонентов из массива
Удаление однотипных компонентов из массива
Жизненый цикл компонента
Хук useEffect
React devtools
Анимации React компонентов
Обмен данными между компонентами
Хук useMemo
Хук useRef
React Router
useNavigate, useLocation и useParams
Контекст, хук useContext
Кастомный хук
React работа с библиотекой Axios




Чтоб React работал надо писать надо в Visual Studio Code

Нужно открывать сайт в локальном сервере, для этого надо:
1)Нажать в панеле возможностей на 4 квадрата
2)Ввести live
3)Скачать локальный сервер
4)Нажать на html проект правой клавишой и потом надать на open with Live Server

Чтоб подключить библиотеки React JS и React DOM к коду надо прописать это:

<script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script> - это для React JS
<script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script> - это для React DOM
Лучше всего подключать это в конец тега header (перед body то есть подключением всего контента и JS)

Но чтоб React JS работал его надо переводить на обычный JS. Для этого есть библиотека Babel.

<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script> - это для подключения React JS
Это подключение надо прописать после подключения React JS и React DOM.

Также надо всем тегам script, которые подключают JS прописать атрибут type="text/babel"



React JS можно также добавить через терменал с помощью node js.

Для этого нужно скачать node js (Скачен)

Чтобы создать react проект нужно прописать в терменале эту команду: npx create-react-app имя файла (Вместо имени файла можно прописать точку, которая указывает на папку в которой был открыт терменал)

Чтобы открыть react приложение нужно прописать эту команду: npm start

*Если название папки в которой будет react приложение имеет неправильное название, то react не подключится

Дальше в главную папку добавятся разные файлы, удаляем ненужные (картинки), оставляем только файл index.html в папке public, файл index.html в папке src и все остальные файлы, которые не находятся в папках(.gitignore и т.п.) заходим в файл index.html и удаляем ненужные коментарии, метаданые и линки.

В js файлы нужно подключить React и ReactDOM для этого их нужно импортировать: import React from 'react' и import ReactDOM from 'react-dom'

В файле index.html нету тега script, но в этот файл приходит весь JS и JSX из файла index.js (Только из него единого, и никакого другого)


ReactDOM - Это объект, с помощью которого можно обращаться к HTML странице и выбирать из нее какие-то элементы

У ReactDOM есть метод render() - это метод, который помещает в какой-то элемент страницы другой элемент страницы.

ReactDOM.render(<тег>Елемент, который будет помещен куда-то</тег>, элемент, в который будет помещен предыдущий тег).

С помощью ReactDOM.render() можно вставить только один элемент, но можно вставить тег div и внутырь div вставить много других тегов.



_____




JSX

JSX - JavaScript XML - это когда мы можем написать HTML код в JS (Он встроен в ReactJS поумолчанию)

Можно писать HTML теги в JS даже при создании переменной:
const elem = <p title="Text">Text</p> (В теге можно прописывать атрибуты и события) (Если бы атрибут title выводил бы какую-то переменую, то надо было бы её прописывать не в кавычках а в фигурных скобках)

Но для добавления тегу события через React JS нужно писать не как в HTML (onclick="func"), а вот-так (onClick={}) (первая буква каждого нового слова большая и вместо кавычек фигурные скобки,
а внутри скобок можно писать функции, переменные, условия и т.д.)

Фигурные скобки в JSX пишим для того, чтоб писать в них JS.

Если хотим чтоб переменная хранила несколько тегов, то надо делать так:

const elems = (<div>
<p>Header</p>
<p>Text</p>
</div>)

Надо писать все теги в одном (в div) и все это писать в круглых скобках

Чтоб добавить в React JS HTML элементу класс нужно прописать атрибут className="имя класса", а не class="имя класса".



_____




Компоненты

Компоненты - это какой-то блок на сайте (кнопка, шапка, форма...).

Создать компонент можно через функцию или класс:

function Comp() {
 return(<div>
	  <h1>Header</h1>
	  <p>Text</p>
        </div>)
} - Создался компонент Comp, в котором есть h1 и p внутри div, дальше его можно вставить в какой-то элемент.


class Comp extends React.Component{
render(){ //имя функции обязательно должно быть render
   return(<div>
	  <h1>Header</h1>
	  <p>Text</p>
        </div>)
 }
} - Создался компонент Comp, в котором есть h1 и p внутри div, дальше его можно вставить в какой-то элемент.

Внутри компонента можно также создавать переменные.


Внутри создания компонента можно прописать другой компонент.

Чтоб вывести компонент нужно прописать <Имя компонента/>

Один и тот же компонент можно выводить несколько раз.

С помощью props можно передавать значение свойств:

<Comp имяСвойства="значение"/> можно создавать несколько свойств.

А в классе пишим у какого-то элемента так: <p>{this.props.имяСвойства}</p> И теперь у какого-то компонента содержимое элемента p будет значение какого-то свойства.

Компоненты можно передавать с одного файла в другой с помощью export и inport.

У всех компонентов есть пропс children, который отвечает за все элемениы, которые находяться внутри него:

	<Comp>
	    <div>               \
		Content           - это элементы, которые находяться внутри компонента Comp (то есть его контент) (то есть его children)
	    </div>		/
	</Comp>

function Comp({children}){ - children - это пропс, который отвечает за элементы, которые находяться внутри компонента Comp (то есть его контент)
	return(
	  {children} - это пропс children, то есть контент
	)
}

_____




Состояния

Состояния нужны для того, чтоб хранить и управлять динамическими данными, которые могут изменяться в течение жизненного цикла компонента на стронице сайта.

чтоб работать с состояниями нужно в классе компонента создать constructor с super, в котором будет props

class Comp extends React.Component{
	constructor(props){
	  super(props)
	  this.state = {
	     состояние:значение состояния по умолчанию, (эта переменна(состояние) будет поумолчанию(с самого начала) иметь это значение) //Это состояние имеет поумолчанию это значение
          }
	}	
}

Теперь нужно каждый раз прописывать не Comp.состояние, а Comp.state.состояние

Чтоб поменять знаечние состояния нужно прописать так:

this.setState({состояние:новое значение})

Если мы пытаемся изменить значение состояния в своих методах, то нужно в конструкторе этого компонента сдеать так:

this.метод = this.метод.bind(this)



_____




props

props - это входные данные (Если есть несколько одинаковых компонентов, но нужно, чтоб у каждого из них был разный контент, то для этого нужно указывать контент в props для каждого такого компонента)

Можно сказать, что props хранит в себе значения (эти значения нужно писать как атребуты в компоненте)	

props нужно писать аргументом функции компонента	

Также вместо того, чтоб аргументом функции компонента props можно прописать {нужный пропс}

Чтоб обратится к этим значениям через props нужно писать так: props.значение (Если мы написали так: {нужный пропс}, то в дальнейшем можно писать не props.нужный пропс, а сразу нужный пропс)

function Comp(props) { - дали компоненту Comp props, тоесть входные данные
  return(
	<h1> {props.text} </h1> - тут контент у тега h1 компоненета Comp будет props.text, значение свойства text укажим при создании компонента
        )
}

<Comp text={"Hello world"}/> - создали компонент Comp у которого свойство text будет со значением "Hello world"

Таких свойств в компонент можно передавать сколько угодно, значения могут быть любого типа данных.



_____




Условия в JSX

Чтоб проверить какое-то условие внутри JSX нужно написать так:

Что мы проверяем ? Результат, если то, что мы проверяем = true
: Другой результат, если то, что мы проверели = false



_____




Добавление стилей

Стили можно добавить в React проект тремя способами:

1. С помощью атрибуута style
атрибут style пишим не как в HTML style="", а вот так style={{}}, первые скобки для JS кода, вторые - для CSS стилей


2.С помощью атрибута className
Как уже было написано раньше, класс можно добавить в react с помощью свойства className, а не class. К этим классам можно обращаться в css файлах.

В react проект нужно импортировать css файл, чтоб работали все стили: import './папака где css файлы/ имя css файла.css'

3.С помощью модульности
Для этого нужно создать обычный CSS файл, но после имени файла пишим .module и уже потом .css
Чтоб импортировать модульный CSS файл нужно импортировать так:
import styles from 'путь к CSS файлу'

такие стили нужно добавлять также через атртбут className, но писать нужно чуть-чуть по другому: className{styles.имя класса, который хотим добавить}

В конечном итоге этот способ изменяет имя класса, который был передан элементу для того, чтоб имена классов не повторялись.

*Важно, чтоб стиль и js/jsx проект были в одной и тойже папке


_____




Добавление картинки

Есть два способа чтоб добавить картинку:

1.С помощью атрибута src
Картинку нужно добавить в какую-то папку проекта и потом можно импортировать ее в React проект (import имя картинки(например img) from 'путь к картинке')
После чего нужно создать тег <img/> в React проекте с помощью JSX и добавить ему атрибут src, значение которого будет импортированая картинка (<img src={img}/>)

2.С помощью тега style
Создаем div с атрибутом style, внутрь пишим стиль backgroundImage: 'url(тут пишим путь к картинке)'

Для того чтоб менять стили картинки(размер, положение) нужнно дать атрибут className либо тегу img либо тегу div смотря на то, какой метод был выбран, а потом в CSS файле этому классу даем нужные стили

*Важно, чтоб картинка и js/jsx проект были в одной и тойже папке


_____




Хуки

Хуки предоставляют более простой и прямолинейный способ работы с состояниями и жизненным циклом компонентов в функциональных компонентах React, делая их более мощными и легкими для использования.

Хуки позволяют функциональным компонентам иметь свои собственные состояния, подписываться на изменения состояний и выполнять другие действия, которые ранее были доступны только классовым компонентам.

Все хуки начинаются с use (Если метод начинается с use, то это хук)

Чтоб хуки работали нужно в начале кода прописать это  const { названия хуков(useState) } = React
Но их можно просто импортировать import { названия хуков(useState) } from 'react'

Также, чтоб хуки работали нужно их писать перед return



_____




Хук useState()

Чтоб добавить состояние в функциональный компонент (компонент, который был создан в функции, а не в классе) надо использовать хук useState().

let имя хука = useState(значение) - если выведем имя хука в консоль, то увидим массив, в котором будет два элемента (значение и функцию) функция - это то, с помощью чего можно менять значение.

Чтоб правильно создать хук нужно писать так:

let [имя хука, имя функции] = useState(значение по умолчанию)

Дальше в функции компонента можно прописать имя функции хука и в скобках написать новое значение состояния.
(Имя хука возвращает значение хука, тоесть, если где-то написать имя хука, то вернется его значение)



_____




Virtual DOM

Virtual DOM (виртуальное DOM) - это концепция, используемая в библиотеке React для эффективного обновления пользовательского интерфейса.

React использует виртуальное DOM как промежуточное представление реального DOM-дерева. Реальное DOM-дерево представляет структуру веб-страницы, состоящую из элементов HTML. Каждый раз, когда происходят изменения данных или состояния в React-компонентах, React создает новое виртуальное DOM-дерево, представляющее обновленный пользовательский интерфейс.

Виртуальное DOM является легковесным и изолированным от реального DOM. Оно представляет собой обычный JavaScript-объект, содержащий информацию о структуре компонентов и их свойствах. Когда происходят изменения, React сравнивает предыдущее виртуальное DOM с новым и определяет минимальное количество мутаций, которые необходимо применить к реальному DOM-дереву для обновления интерфейса. Это позволяет уменьшить нагрузку на браузер и улучшить производительность при обновлении интерфейса.

После вычисления различий между предыдущим и новым виртуальным DOM, React применяет только необходимые изменения к реальному DOM, минимизируя количество фактических операций взаимодействия с браузером. Это позволяет обновлять пользовательский интерфейс эффективно и плавно.

Использование виртуального DOM является одним из ключевых преимуществ React и помогает разработчикам создавать быстрые, отзывчивые и масштабируемые веб-приложения.




_____




Создание однотипных компонентов из массива

Если нужно добавить очень много однотипных компонентов с разным контентом, то это можно сделать с помощью массива:

Нужно создать переменную, которая будет периберать массив с объектами с помощью метода map создовать компонент от объекта массива

Далее основной компонент должен возвращать див, в котором будет тот элемент, который создал компонент от объекта массива

Пример:

function Comp(){
  const arr = [ //Создаем массив с объектами
    {header : 'First', body : 'Buy a bread',  key: '1' },
    {header : 'Second', body : 'Buy mimk',  key: '2' },
    {header : 'Third', body : 'Buy  eggs',  key: '3' },
    {header : 'Fourth', body : 'Buy vegetables',  key: '4' },
    {header : 'Fifth', body : 'Buy sausages',  key: '5' },
  ]

  const el = arr.map((el) => { //Создаем переменную, которая периберает массив с объектами и создает(возвращает) компонент от этого объекта массива
    return(
    <div key={el.key}>
      <hr/>
      <h1>{el.header}</h1>
      <p>{el.body}</p>
      <hr/>
    </div>)
  })

  return( //Основной компонент Comp возвращает div, в котором будет переменная el, то есть все объекты массива arr
    <div>
      {el}
    </div>
  )
}

НО все это можно записать проще:

function Comp(){
   let [posts, setPosts] = useState([ //Создаем состояние posts, которое будет возвращать массив объектов
    {header : 'First', body : 'Buy a bread',  key: '1' },
    {header : 'Second', body : 'Buy mimk',  key: '2' },
    {header : 'Third', body : 'Buy  eggs',  key: '3' },
    {header : 'Fourth', body : 'Buy vegetables',  key: '4' },
    {header : 'Fifth', body : 'Buy sausages',  key: '5' },
  ])

  return( //Рендерим компонент Comp
    <div>
      {posts.map(post => { //Перебераем массив posts
	return( //Рендерим каждый объект массива отдельно
	  <div key={post.key}> //Основной div, у которого будет id и внутри него будут все остальные теги
	     <div> {post.header} </div>
	     <div> {post.body} </div>
	  </div>
	)})}
    </div>
  )
}

Также в компонент, который был создан с помощью map нужно добавить атрибут key с индивидуальным значением (значением может быть свойство компонента, а этот ключ нужно прописывать атрибутом в компонент).


Компонент можно также записывать так: <Comp> Содержимие </Comp>

Но содержимое не будет видно. Для того чтоб содержимое было видно нужно в создании компонента прописать такое содержимое: {props.children}
После того как прописали {props.children} содержимое, которое было прописано в компоненте будет видно

Если какой-то атрибут не добавляется в компонент, то нужно сделать так:
Аргуметы в создании компонента будут такими (children, ...props) (Так как children - это свойство, которое есть в props по умолчанию)
А в сам элемент добавить атрибут {...props}

function Comp(children, ...props){
   <button {...props}>
	{props.children}
   </button>
}

<Comp disabled> Содержимое </Comp> - Если б при создании компонента мы б не прописали в buttton атрибут ...props, то disabled не работал бы.




!!!!!!


function more(id){
        let newArr = props.posts.map((el) => {
            if(el.id == id){
               return {id:el.id, title:el.title, description:el.description, rating:el.rating + 1};
            }
            return el;
        })
        props.setPosts(newArr);
    }
функция more находиться в компоненте Post и по этому имеет доступ к его props, по-этому мы можем использовать в функции more props для того, чтоб обратиться к данным
(в нашем случяи к массиву props), далее мы перебираем массив props.posts с помощью map, где элемент, который сейчас перебирается - это el, и фактически так, как мы обратились к массиву
posps, а это [{id:0, title:"TTT", description:"ddd", rating:0,}, {id:1, title:"TTT2", description:"ddd2", rating:0,}], то мы, как бы сейчас находимся в нем , и у него нет никакого props и по-этому
когда я пытаюсь обратится к props внутри  props.posts.map((el) => {..(тут)..} мне выводит ошибку потому-что я сейчас внутри объекта массива posts и там нет props. По этому я обращаюсь
к el, ведь, el - это элемент, который сейчас проверяеться, и у него есть данные id, title, description и rating, а вот props у него нет, по-этому мне выводило ошибку, когда я обращался к props.

Это если что проэкт multy_test(там можно увидеть полный код в папке post.js) (я делаю рейтинг(лайки) элементу)

!!!!!!


_____



Удаление элементов из массива

Чтоб удалить какой-то элемент из массива нужно воспользоватся методом filter

Сперва создаем функцию, которая будет удалять элемент из массива:

let del = (id) => {
   let newArr = arr.filter((el) => el.id !== id);
   setArr(newArr);
}

Далее нужно передать в создание компонента пропсом(свойством) функцию, которая будет выполнять функцию удаления (вместо id в скобках нужно указать id компонента (el.id))

<Exer delete={() => del(el.id)} key={el.id}/>

Дальше нужно создать в файле создания компонента выполнять эту функцию, обращаясь к ней через пропс (например при событии onClick)

expolt default function Exer(props) {
    return(){
	<div>
	  <div onClick={() => {props.delete()}}>X</div>
	  <p>Text</p>
	</div>
    }
}

______




Жизненый цикл компонента

Жизненный цикл компонента в React описывает различные этапы, через которые проходит компонент, начиная с его создания и заканчивая удалением.

Этапы жизненого цикла:

1. Монтирование (Mounting):
Монтирование - это этап, при котором компонент впервые создается и рендерится в DOM.

Методы монтирования:

constructor: В этом методе вы можете инициализировать состояние компонента (this.state) и привязать методы к экземпляру класса (если компонент классовый, а не функциональный).
render: Метод render отображает компонент и его дочерние элементы. 
componentDidMount(): Этот метод вызывается после того, как компонент и его дочерние элементы отрендерены в виртуальном DOM и добавлены в реальный DOM.


2. Обновление (Updating):
Обновление - это этап, при котором компонент обновляется в ответ на изменения состояния или свойств (это стадия активной жизни компонента, когда он работает и виден).

Методы обновления:

static getDerivedStateFromProps: Этот статический метод вызывается перед рендерингом компонента и при каждом обновлении. Он позволяет обновить состояние компонента на основе новых свойств (props).
shouldComponentUpdate: Этот метод определяет, должен ли компонент перерисовываться после изменения состояния или свойств.
render: Метод render обновляет отображение компонента и его дочерних элементов.
componentDidUpdate: Этот метод вызывается после обновления компонента и его дочерних элементов в DOM.


3. Размонтирование (Unmounting):
Размонтирование - это этап, когда компонент удаляется из DOM.

Методы размонтирования:

componentWillUnmount: Этот метод вызывается перед удалением компонента из DOM.



_____




Хук useEffect

Хук useEffect() - это хук, который автоматически выполняет какой-то код при изменении какого-либо состояния компонента.

У хука useEffect() есть два аргумента, первый - это колбэк функция, второй - массив зависимостей(массив зависимостей - это те знаения, при изменении которых будет срабатывать хук useEffect).
Если массив пустой, то хук сработает только один раз - при первой загрузке компонента.

useEffect(() => {
 код, который будет срабатывать
}, [зависимости])

Но если мы делаем компонент с помощью класса, то вместо хука useEffect() можно использовать метод componentDidUpdate(), который делает все тоже самое.

componentDidUpdate(){
	код, который будет выполнятся при изменении какого-то состояния.
}



_____




React devtools

React devtools - это инструмент разработчика

React devtools нужно скачать в браузере (Скачен)

После скачивания в инструментах разработчика в браузере будет две новых вкладки: Components и Profiler.

Components нужен для того, чтоб видеть все дерево компонентов, состояния и их значения можно осмотреть пропсы



_____




Анимации React компонентов

Анимации React компонентов лучше использовать чем обычные CSS анимации потому-что если нам нужно добавить несколько анимаций на один класс(появления, исчезания), то у нас ничего не получится потому-что к классу можно добавлять только одну анимацию

По этому нужно использовать Анимации React компонентов

Для добавления анимации к React компоненту нужно в React проект добавить библиотеку react-transition-group, чтоб ее подключить нужно в терменале прописать: npm install react-transition-group --save

React transition group обеспечивает плавные переходы и анимации между различными состояниями компонентов React.
Она предоставляет несколько компонентов, таких как Transition и CSSTransition (есть и другие, но пока скажу о этих).

Чтоб анимации работали их нужно импортировать в проект: import {компонент анимации(Transition, CSSTransition и т.п.)} from 'react-transition-group'


Transition - это компонент, который отвечает за стили какого-то компонента при появлении и исчезании этого компонента.

Внутри комонента Transition должна быть функция, у которой есть аргумент state и эта же функция должна возвращать компонент, который будет анимироватся.

Аргумент state - это текущее состояние анимации компонента, у state может принимать такие значания: entering, entered, exiting и exited.

entering - это состояние соотвецтвует моменту, когда компонент только появился и анимация еще не началась.

entered - это состояние соотвецтвует моменту, когда анимация появления находится в процесе выполнения. Анимация выполнения - это анимация при появлении компонента.

exiting - это состояние соотвецтвует моменту, когда анимация исчезновения находится в процесе выполнения. Анимация исчезновения - это анимация при исчезновении компонента.

exited - это состояние соотвецтвует моменту, когда компонент завершил анимацию исчезновения и вот-вот пропадет.

Пример:

У нас есть сообщение, которое вывелось на экран на пять секунд и потом пропадет

Момент, когда это сообщение только появилось на экран - это entering (Это может быть CSS класс, который дает положение этому сообщению, цвет, прозрачность и т.д.)

Момент, когда это сообщение выдвегается в сторону - это entered (анимация появления) (Это может быть CSS класс, который дает сдвиг этому сообщению, новый цвет, прозрачность и т.д.)

Момент, когда это сообщение задвигается обратно - это exiting (анимация исчезания) (Это может быть CSS класс, который дает сдвиг сообщению, еще раз новый цвет, прозрачность и т.д.)

Момент, когда это сообщение завершило анимацию исчезания и готовится пропасть - это exited (Это может быть CSS класс, который дает плавную полную прозрачность этому сообщению).

Дальше это сообщение пропадет.


У компонента Transition должны быть два пропса(свойства): in и timeout.
in - это свойство, которое указывает, должен ли компонент находится в анимированом состоянии (true) или нет (false) (in может быть равно какой-то переменной, которая будет равна true/false).
timeout - это свойство, которое отвечает за то, сколько будет длится анимация (значение - это количество миллисекунд)


Пример того, как это должно выглядеть:

JS

function App {

isTrue = true;

return(
  <Transition in={isTrue} timeout={500}>
	{(state) => {
			return(
	   			<div className={`box ${state}`}> Content </div> //Зависимо от состояния компонента, значение аргумента state тоже будет меняться и класс, который прописан как ${state} тоже будет менятся, тоесть зависемо от того на каком этаме находится компонент такая у него и будет анимация.
        	    )}}
  </Transition>
 )
}

CSS

.box{
  background-color: red;
  width: 200px;
}

.entering{
  opacity:50%;
}

.entered{
  opacity:100%;
  background-color: blue;
  transform: translate(200px, 0px);
}

.exiting{
  opacity:50%;
  background-color: red;
  transform: translate(0px, 0px);
}

.exited{
  opacity:0%;
}

Если хотим чтоб при значении пропса in = false анимированный компонент удалялся нужно в компонент Transition добавить свойство unmountOnExit. 

Если у нас модульные стили, то у нужно писать так: className={`${style1.anim} ${style1[state]}`}



CSSTransition - это компонент, который позволяет создавать анимации с использованием CSS классов. Он добавляет и удаляет классы в зависимости от состояния компонента.

CSSTransition основывается на CSS классах, что делает его более простым в использовании для создания анимаций с помощью готовых стилей.

Внутри компонента CSSTransition должены быть такие пропсы(свойства): in, timeout и classNames.

in - это свойство, которое указывает, должен ли компонент находится в анимированом состоянии (true) или нет (false) (in может быть равно какой-то переменной, которая будет равна true/false).
timeout - это свойство, которое отвечает за то, сколько будет длится анимация (значение - это количество миллисекунд)
classNames - это свойство, которое определяет имена классов для различных состояний анимации.

Состояния анимации:

enter - состояние, когда компонент начинает появляться.

enter-active - состояние, когда анимация появления находится в процесе выполнения. Анимация выполнения - это анимация при появлении компонента.

exit-active - состояния, когда анимация исчезновения находится в процесе выполнения. Анимация исчезновения - это анимация при исчезновении компонента.

exit - состояние, когда компонент начинает исчезать.

Если вы указали classNames="fade", CSSTransition добавит классы .fade-enter, .fade-enter-active, .fade-exit и .fade-exit-active соответственно для различных состояний анимации.

Обработчики событий:

CSSTransition также предоставляет некоторые обработчики событий, такие как onEnter, onEntering, onEntered, onExit, onExiting и onExited, которые вызываются на разных этапах анимации

onEnter: Этот обработчик события вызывается, когда компонент начинает свой процесс появления.

onEntering: Этот обработчик события вызывается, когда анимация появления находится в процесе выполнения, в состоянии enter-active.

onEntered: Этот обработчик события вызывается, когда компонент полностью появился на экране и анимация появления завершена.

onExit: Этот обработчик события вызывается, когда компонент начинает свой процесс исчезновения. Он вызывается единожды, при добавлении класса exit.

onExiting: Этот обработчик события вызывается, когда анимация исчезновения находится в процесе выполнения, в состоянии exit-active.

onExited: Этот обработчик события вызывается, когда компонент полностью исчезает с экрана и анимация исчезновения завершена.

Пример:

JS


function Fade() {

isOpan = true;

 return(
  <CSSTransition
    in={isOpen}
    timeout={500}
    className='fade' //Это для основных стилей
    classNames='fade' //Это для анимация от CSSTransition
    onEntered={() => console.log('Анимация появления завершена')} //После завершения анимации появления компонента будет вызван обработчик onEntered, который просто выводит сообщение в консоль.
  >
    <div>Компонент для анимации</div>
  </CSSTransition>
  )
 }


CSS

fade{
  backgroundColor: red;
}

.fade-enter-active { //Тут те свойства, которые будут у компонента при его анимации появлении
  opacity: 50%;
  transition: rotate(360deg);
}

fade-enter-done { //Тут те свойства, которые будут у компонента при завершении анимации появления
  opacity: 100%;
  transition: rotate(360deg);
}

.fade-exit-active { //Тут те свойства, которые будут у компонента при его анимации исчезания
  opacity: 50%;
  transition: rotate(0deg);
}

.fade-exit-done { //Тут те свойства, которые будут у компонента при завершении анимации исчезания
  opacity: 0%;
}


Если же мы ходим создать CSSTransition анимацию использовая модульные стили, то свойство classNames нужно писать так:

classNames={{
            enter: styles.addEnter,
            enterActive: styles.addEnterActive,
            exit: styles.addExit,
            exitActive: styles.addExitActive,
            }}

А потом это свойства (addEnter, addEnterActive, addExit, addExitActive), написать в css файле



_____




Обмен данными между компонентами

props - это аргументы, параметры, которые принимает компонент из вне, но обмен этими пропсами идет всегда от родительского компонента к дочернему (дочерний компонент - это компонент, который находится внутри другого компонента(родительского))



Передача данных от родительского компонента к дочернему:



function Parent(){ 		      //Это родительский компонент, потому-что он рендерит другой компонент (дочерний)
   let word = `Hello!`	              // Переменная word - это строка `Hello!`

   return(<Child content={word}/>)    //Содержимое компонента Parent - это компонент Child(он дочерний, потому-что врунтри другого компонента) у него есть свойство(не состояние!!!) content, которое равно переменной word, тоесть строке `Hello!` любое свойство компонента - это параметр и поэтому оно попвдет в props
}

function Child(props){		      // Это создание компонента Child у него есть props, тоесть некоторые параметры(его свойства - это тоже параметры)
   return(<h1>{props.content}</h1>)   //Содержимое компонента Child - это заголовок, который возвращает props.content, тоесть параметр(свойство) content, значение которого было прописано в рендеринге компонента Parent
}



Передача данных от дочернего компонента к родительскому:



function Parent(){ //Это родительский компонент, потому-что он рендерит другой компонент (дочерний)
  let [data, setData] = useState(`Изночальное значение`); //Это состояние data с функцией setData, data изначально равно какому-то изначальному значению
  
  let setNewData = (newData) => { //Это функция setNewData с аргументом newData, которое меняет значение состояния data на этот аргумент newData
	setData(newData)
 }


 return( //Содержимое компонентс Parent - это дочерний компонент Child со свойствами data, которое равно состоянию data компонента Parent и newFunc, которое равно функции setNewData (эти свойства попадут в props компонента Child)
  <div>
    <Child data={data} newFunc={setNewData}/>
  </div>
 )
}

function Child(props){ //Это компонент Child у него есть props, тоесть некоторые параметры(его свойства - это тож параметры)
  let click = () => { // Это функция click, она создает переменную newData с каким-то значение и она выполняет функцию props.newFunc(), вернее это свойство пропса, которое равно функции setNewData (Мы это прописали в рендере компонента Parent) и аргументом в эту функцию передается переменная newData, которая создается в функции click
     let newData = "Новые данные"
     props.newFunc(newData) //Эта функция изменяет значение состояния data на переменную newData, которая была создана в функции click
 }

  return( //Содержимое компонента Child - это заголовок с содержимым props.data, тоесть содержимое - это значение сврйство data, которое было передано в компонент Child при рендере компонента Parent
   <div>
     <h1>{props.data}</h1>
     <button onClick={click}>Изменить данные</button> //Это кнопка, которая при нажатии вызывает функцию click, тоесть меняется значение состояния data на переменую newData
   </div>
 )
}



_____




Хук useMemo

Если у нас есть какая-та большая функция, которая делает какие-то операции над некоторыми данными, то выполнение такой функции может занимать много времени, и даже если функция уже выполнялась и данные никак не изменились с предедущего выполнения, то функция всеравно будет выполнятся полностью, что займет много времени и вернет тот же результат

let memo = () => { //Эта функция создает переменные a,b и c, через 2 секунды выводит в консоль переменную c и возвращает c, тоесть функция memo равна значению переменной c.
  let a = 5;
  let b = 6;
  let c = a + b;
  setTimeout(() => {console.log(c)}, 2000);
  return c;
};

Через-то, что для выполнения данной функции требуеться более 2 секунд, такая функция может сильно нагружать сайт, тем более если эта функция часто вызываеться, и это при том, что эта функция каждый раз возврошает один и тот же результат.

 

Но с хуком useMemo такого не будет

useMemo - это хук, в котором есть два параметра: колбэк функция и массив с какими-то данными, и перед каждым выполнения функциич useMemo проверяет: изменились ли данные, которые прописаны в массиве вторым аргументом, если да, то функция выполняется полностью с начала и запоменает результат (происходит мемоизация: данные о выполнении функции кэшируются), если же данные в массиве никак не изменились с прошлого выполнения, то useMemo не выполняет функцию с начала, а просто возвращает результат функции с прошлого раза

И у колбэк функция должна возвращать что-то (у нее должен быть return)

let [value, setValue] = useState(false); //Создаем состояние value

  let memo = useMemo(() => { //Переменная memo равна хуку useMemo, который возвращает функция и массив с параметрами. Хук useMemo похож на хук useEffect они оба выполняються при рендеринге и при изменении массива параметров
    let a = 5;
    let b = 6;
    let c = a + b;
    setTimeout(() => {console.log(c)}, 2000);
    return c; 
  }, [value]); //В массиве параметров находится состояние value, тоесть при изменении этого состояния функция(первый параметр хука) будет выполнятся с самого начала.

  return(
    <div>
      <br></br>
      <div onClick={() => {console.log(memo)}}>Enter</div> //При нажатии на кнопку в консоль будет выводится переменная memo, тоесть ее return, а это переменная c
      <div onClick={() => {setValue(!value)}}>Chenge</div> //При нажатии будет менятся значение состояния value, тоесть будут менятся массив параметров, изза чего функция будет выполнятся сначала.
    </div>
  )

}

А теперь подробнее:
	Хук useMemo похож на хук useEffect они оба выполняються при рендеринге и при изменении массива параметров.
	При загрузке сайта происходит рендер всех компонентов, а также рендерится хук useMemo тогда, когда рендерится компонент, в котором находится хук useMemo.
	В этом(первом) рендеринге функция выполняеться полностью, запоменая свой результат и массив параметров (происходит кэширование(мемоизация)).
	Когда мы будем повторно выводить memo(ту переменную, которая равна переменной useMemo) функция внутри useMemo не будет выполнятся сначала, занимая кучу времени, она вернет тот return, который был с прошлого выполнения функции.
	Но если изменится какой-то параметр из массива параметров, то во-первых произойдет рендер(он приисходит при изменении состояний), а во-вторых изза рендера функция хука выполниться заново и хук заметит, что параметр изменил свое значение изза чего функция хука выполниться с самого начала и в конце все закэширует

_____




Хук useRef()

С помощью хука useRef можно получать доступ к DOM елементу.

let имя хука = useRef()

В какой-то React элемент нужно прописать атрибут ref={имя ref хука}

Дальше можно где-то прописать так: имя ref хука.current.что хотим получить (current - это тот React элемент, которому мы прописывали ранее ref={имя ref хука} с него мы можем получить какую-то React информацию (value, ))

Но если мы хотим работать с хуком useRef c нашим компонентом, то нужно пользоватся функцией forwardRef:

Компонент нужно оборачивать в функцию forwardRef, обязательным аргументом такого компонента должен быть ref

const Comp = React.forwardRef((props, ref) => {
  return(
 	<h1>Text</h1>
        )
})

Дальше нужно создать хук useRef

И в компонент прописать ref={имя хука useRef}

<Comp ref={имя хука useRef}/>

Также если у нас большой компонент и нам нужно получать React информацию только с какого-то определенного элемента, то этому компоненту нужно прописать атрибут ref={ref}


Чтоб в состояние-массив добавить новый элемент (добавит еще один элемент(объект), а не заменить все предедущие на один новый нужно писать так: функция состояния-массива([...имя хука useState(имя состояния-массива, в котором хранятся элементы(объекты)), новый элемент]))



_____



React Router

React Router - это библиотека маршрутизации для React-приложений. Она предоставляет навигационные компоненты, которые позволяют создавать динамические одностраничные приложения с различными маршрутами.


Чтоб установить React Router нужно в терменал прописать npm install react-router-dom

Потом нужно импортировать все те его компоненты которыми мы будем пользоватся: import {нужные компоненты} from 'react-router-dom@6'


Основные компоненты React Router:

BrowserRouter
BrowserRouter: Этот компонент используется для обертывания основного приложения и предоставляет контекст для других компонентов React Router.


Route
Route: Этот компонент определяет маршрут внутри приложения. Он принимает два основных свойства: path - путь, соответствующий URL, и element - компонент, который должен быть отображен, когда URL соответствует указанному пути.
*Теперь если мы напишим Route внутри BrowserRouter, дадим ему свойства path="/название" и element={<компонент/>}), то при вводе в URL строку то, что написано в свойстве path нас перебросит на страницу, где будет только тот компонент, который написан в свойстве element={<компонент/>}

Чтоб сделать ссылку, которая будет открывать страницу, если ни один Route не подошел надо прописать так: path="*"


Routes
Routes: Этот компонент используеться для проверки всех Route. При переходе по какому-то URL компонент Routes проходит по всем Route которые в нем записаны, и если записаное URL совпадает с URL какото-то компонента Rounte, то мы перейдем на этот Route.


Link
Link: Этот компонент используется для создания ссылок внутри приложения. Он генерирует HTML-элемент <a>, который позволяет пользователям нажимать на ссылки и переходить на другие маршруты в приложении, у компонента Link есть свойство to, которое принемает URL того Route, на который мы хотим перейти при этом страницы не перезагружаются.

*Тоесть место того, чтоб пользователю писать в URL строку адрес какого-то компонента Route и так переходиь на другую станицу, можно на сайт добавить компонент Link и в нем прописать свойство to со значением URL адруса кокого-то Route, то при нажатии на это компонент пользователя перекинет на эту страницу

NavLink
NavLink: Это компонент делает тоже самое, что и компонент Link, но к текущему маршруту додаеться класс active, который прописываеться в CSS файле.


Пример

import React from 'react'; //Импортируем React
import { BrowserRouter, Route, Routes, Link} from 'react-router-dom'; //Импортируем все те компоненты, которыми будем пользоватся из 'react-router-dom'

import Home from './pages/Home'; //Импортируем компонент Home из проекта './pages/Home'
import About from './pages/About'; //Импортируем компонент About из проекта './pages/About'
	

const App = () => {       		           //Создаем главную страницу сайта - компонент App, на котором будут ссылки на страницы Home и About
  return (
    <BrowserRouter>   		       	      	   //Создаем компонент BrowserRouter, в котором будет основное преложение и в нем будут прописыватся остальные теги этой библиотеки
      <nav>  		  		      	   //Создаем навигацию в которой будут ссылки на остальные страницы
        <ul>
          <li>
            <Link to="/home">Home</Link>           //Эта ссылка будет ввести на станицу по URL /home
          </li>
          <li>
            <Link to="/about">About</Link>   	   //Эта ссылка будет ввести на станицу по URL /about
          </li>
        </ul>
      </nav>

      <Routes> 				            //Создаем компонент Routes, который будет проверять: по какому URL мы пошли и будет пересылать нас на страницу с содержимым по этому URL 
        <Route path="/home" element={<Home/>} />    //Этот Route - это страница где содержимое только компонент Home и у этой страницы URL /home
        <Route path="/about" element={<About/>}>    //Этот Route - это страница где содержимое только компонент About и у этой страницы URL /about
      </Routes>
    </BrowserRouter>
  );
};



_____




Хуки useNavigate, useLocation и useParams

У библиотеки React Router также есть свои хуки: useNavigate, useLocation и useParams

Чтоб хуки useNavigate и useParams работали их нужно импортировать: import { useNavigate, useParams } from 'react-router-dom';


Хук useNavigate предоставляет доступ к объекту истории, который позволяет управлять историей браузера внутри компонента.

Для начала нужно создать переменную, которая будет равна хуку useNavigate (let nav = useNavigate())

Далее мы можем с помощью переменной nav перемещатся по истории сайта.

nav(index) - с помощью такой записи можно перемещатся по истории, если индекс отрецательный, то перемещаемся назад, если положительный - вперед.

nav('URL') - с помощью такой записи можно перемещатся между страницами(маршрутами), если меняеться URL, но на сайте ничего не пеняеться можно создать такую функцию: () => {nav('/'); window.location.reload()}, где window.location.reload() перезагружают сайт. 

Чтоб работало нужно написать хук useNavigate в одном компоненте и этот компонент засунуть в основной компонент.


Хук useLocation

Этот хук получает объект данных про текущий маршрут.

Чтоб пулучить объект данных нужно создать переменную, которая равна хуку useLocation (let loc = useLocation())

Чтоб получить объект данных нужно вывести в коонсоль переменную, которая равна хуку useLocation  (console.log(loc))

Чтоб работало нужно написать хук useLocation в одном компоненте и этот компонент засунуть в основной компонент.


Хук useParams позволяет получить параметры маршрута из URL. Он полезен, когда ты определяешь динамические маршруты с переменными частями пути.

Параметры маршрута - это динамические части пути URL, которые используются для передачи данных или идентификаторов в маршруты.
Они позволяют создавать гибкие и динамические маршруты, которые могут обрабатывать различные значения.

Для определения параметров маршрута в React Router используется синтаксис с двоеточием (:) перед именем параметра в определении пути маршрута.
Например, путь маршрута может выглядеть так: /users/:id, где :id - это параметр маршрута.

Но если у нас есть URL /posts и URL /posts:id, то Router будет воспринимать два этих URL одинаково потому-что у них обих есть часть /posts, чтоб Router воспринимал их как разне нужно перед ними прописать exact.
<Route exact path="/posts"/>
<Route exact path="/posts/:id"/>

Например, маршрут может выглядеть как /users/123, где 123 - значение параметра id, то useParams вернет объект { id: "123" }

Чтоб работало нужно написать хук useParams в одном компоненте и этот компонент засунуть в основной компонент.


Если на сайте будет допустим 100 маршрутов на сайте, и если для каждого из них делать свой Route, то это будет не экономно и не красиво.

В таком случаи можно создать отдельный проект где будет какой-то массив, в котором будут объекты со свойствами, значение которых будут: URL на компоненты; сам компонент, на который будем переходить по URL и exact со значением true (его добавляем в том случаи, если у нас URL у некоторых компонентов имеют одинаковое начало)
Создаем таких объектов столько, сколько у нас маршрутов на сайте.

Далее на основной проект, где находится вся маршутизация (где есть компоненты BrowserRouter, Routes, Link и т.д.) импортируем это массив и с помощью метода map перебераем его объекты, отрисовывая для каждого из объектов свой Route со свойствами, значение которых - это свойства объектов:

Пример:

Проект с массивом:

import Comp1 from 'путь к проекту' //Импортируем первый компонент, на который будем переходить
import Comp2 from 'путь к проекту' //Импортируем второй компонент, на который будем переходить
import Comp3 from 'путь к проекту' //Импортируем третий компонент, на который будем переходить
и т. д.

export let arr = [ //Создаем и экспартируем массив с объектами
  {path: '/comp1', element: Comp1, exact: true} //Создаем первый объект со всеми нужными свойствами
  {path: '/comp2', element: Comp2, exact: true} //Создаем второй объект со всеми нужными свойствами
  {path: '/comp3', element: Comp3, exact: true} //Создаем третий объект со всеми нужными свойствами
  и т. д.
]


Проект с маршутизацией

import React from 'react'; //Импортируем React
import { BrowserRouter, Route, Routes, Link} from 'react-router-dom'; //Импортируем все те компоненты, которыми будем пользоватся из 'react-router-dom'

import arr form 'путь к проекту' //Импортируем массив из предедущего проекта

let App = () => { //Создаем компонент с маршутизацией
   return(
	<Routes>
	  {arr.map(obj => //Перебераем объекты массива arr 
		<Route element={obj.component} path={obj.path} exact={obj.exact} /> //Создаем маршуты Route на основе объектов массива arr (Тоесть вместо того, чтоб писать кучу маршрутов Route мы перебераем объекты массива arr и пишим один раз Route, на подобии которого будут создаватся все маршруты и они будут брать свойства path, component и exact из объекта, от которого они создаются).
	  )}
	</Routes>
 )
}



Чтоб сделать так, чтоб допустим авторизованные пользователи видели контент, а не авторизованные нет, то нужно сделать так:

Пример:

Проект с массивом:

import Comp1 from 'путь к проекту' //Импортируем первый компонент, на который будем переходить
import Comp2 from 'путь к проекту' //Импортируем второй компонент, на который будем переходить
import Comp3 from 'путь к проекту' //Импортируем третий компонент, на который будем переходить
и т. д.

import Login from 'путь к проекту с регистрацией' //Импортируем компонент с регистрацией

export let private = [ //Создаем и экспартируем массив с объектами для зарегестрированных пользователей
  {path: '/comp1', element: Comp1, exact: true} //Создаем первый объект со всеми нужными свойствами
  {path: '/comp2', element: Comp2, exact: true} //Создаем второй объект со всеми нужными свойствами
  {path: '/comp3', element: Comp3, exact: true} //Создаем третий объект со всеми нужными свойствами
  и т. д.
]

export let public = [ //Создаем и экспартируем массив с объектами для не зарегестрированных пользователей
  {path: '/login', element: Login, exact: true} //Создаем объект со свойствами, которые хранят всю информацию для регестрации
]


Проект с маршутизацией

import React from 'react'; //Импортируем React
import { BrowserRouter, Route, Routes, Link} from 'react-router-dom'; //Импортируем все те компоненты, которыми будем пользоватся из 'react-router-dom'

import private form 'путь к проекту' //Импортируем массив с объектами для зарегестрированных пользователей
import public form 'путь к проекту' //Импортируем массив с объектами для не зарегестрированных пользователей

let App = () => { //Создаем компонент с маршутизацией
   let isAuth = false; //Переменная isAuth отвечает за то, что авторизовыванный пользователь(true) или нет(false)
   return(
	isAuth //Проверяем переменную isAuth
	 ?	//Если true, то 
	<Routes>
	  {private.map(obj => //Перебераем объекты массива private
		<Route element={obj.component} path={obj.path} exact={obj.exact} /> //Рендерим все те маршруты, которые есть в массиве private
	  )}
	</Routes>
	 :      //Иначе
	<Routes>
	  {public.map(obj => //Перебераем объекты массива public
		<Route element={obj.component} path={obj.path} exact={obj.exact} /> //Рендерим все те маршруты, которые есть в массиве public (то есть это страница с регистрацией)
	  )}
	</Routes>

 )
}



_____




Контекст, хук useContext

Если у нас есть 10 вложеных в друг друга компонентов и нам нужно от прародителя передать какие-то данные в самый дочерний компонент, то передовать эти данные пропсом через все промежуточные
компоненты будет долго и неудобно. Для этого и нужно пользоватся контекстом.

Контекст в React используется для передачи данных от верхних компонентов к нижним компонентам в иерархии без явной передачи пропсов через каждый промежуточный компонент.
Он предоставляет глобальные переменные, которые могут быть доступны в любом месте в приложении.

То есть контекст - это компонент, который передает какие-то данные другим(дочерним) компонентам.

Чтоб создать контекст нужно сначала импортировать метод createContext из React, а потом уже создавать контекст (его нужно создавать вне компонента):
let Context = React.createContext(данные по умолчанию) (Мы создади контекст Context)

Далее нужно в родительский компонент(тот с которого будут переходить данные) вставить провайдер контекст-компонента(Context.Provider), в котором будут те дочерние компоненты, которым мы передадим этот данные указанные в свойстве value:

<Context.Provider value={данные контекста, которые передеются}>
  <дочерний компонент, который получает данные/>
</Context.Provider>


Потом нужно в ретурне дочернего компонента прописать <Context.Consumer> а в нем функцию, которая возвращает value, которое передаеться с родительского Context.Privider

<Context.Consumer>
      {(value) => <h1>{value}</h1>}
</Context.Consumer>



Но можно вместо того, чтоб прописывать Context.Consumer воспользоваться хуком useContext:


Нужно в дочернем компоненте, который получает данные создать хук useContext(название контекста) (прежде его нужно импортировать), и значение этого хука будет компонент-контекст, который передает данный от родителя:

let value = useContext(Context) (То есть переменная value - это данный контекста, которые передает родительский компонент)

А потом уже можно в рендере дочернего компонента прописать {value}

Использование хука useContext - это тоже самое, что и Context.Consumer, но на много короче и понятнее.



Пример:

import createComponent from 'react' //Импортируем метод createComponent
import useContext from 'react' //Импортируем хук useContext

let Context = React.createContext("Null") //Создаем контекст Context со значением по умолчанию "Null"

const App = () => { //Создать компонент App 
 let data = "Hello there"; //Создаем переменную data со значением "Hello there"

 return(
  <Context.Provider value={data}> //Передаем значение value, которое равно переменной data напрямую компоненту Child
    <Child/>
  </Context.Provider>
 )
}

const Child = () => { //Создаем компонент Child
 let ctx = useContext(Context) //Используем хук useContext для получения значения контекста Context (значение контекста Context - это переменная value, которая равна переменной data. Это было прописно в компоненте App)

 return(
  <p>{ctx}</p> //Выводим контекст, полученный из контекста Context.
 )
}

Также если мы контекстом передаем объект и мы хотим принять только некоторые его параметры, то нужно писать так:

let {те данные, которые нам нужны} = useContext(Context)



_____




Кастомный хук

Кастомный хук - это совя функция, которая подчиняется всем правилам хука: ее нельзя писать в условии или циклах, она должна быть только на верхнем уровне.
Кастомный хук можно назвать как угодно, но для того чтоб было понятно, что это хук его следует назвать начиная с 'use'.

Кастомный хук создан для того, чтоб избежать повторения какой-то логики в коде.
Кастомные хуки можно использовать в разных компонентах.
В кастомных хуках можно писать другие хуки.

Кастомный хук обязатеньно должен что-то возвращать (у него должен быть return)
В return хука может быть любой тип данных, но чаще всего возвращают массив или объект.

Возврвщвтся должно то, что играет важную роль в этом хуке и без этого хук не будет работать.

Пример:




_____




Кастомный хук:

import {useState} from 'react'   	        //Импортируем хук useState потому-что он мне пригодится

function useCounter(startValue){                //Создаю функцию useCounter, у которой есть аргумент startValue (эта функция и будет кастомным хуком).
  let [count, setCount] = useState(startValue)  //Создаю состояния count, которое по умолчанию будет равно аргументу startValue.

  up(){						//Создаю функцию up, которая увеличивает состояние count на 1
    setCount(count + 1);
  }

  down(){ 					//Создаю функцию down, которая уменьшает состояние count на 1
    setCount(count - 1);
  }

 return [count, up, down]		        //Возвращаю самое важное: состояние count, функции up и down. (без этих параметров этот хук безполезный)
}

export {useCounter} 				//Экспортирую хук useCounter.



Компонент:

import {useCounter} from 'папка'	        //Импортирую хук useCounter.


function App(){				        //Компонент App

 let [count, up, down] = useCounter(0); 	//У компонента App будет кастомный хук useCounter со всеми аргументами и значение состояния count будет равно 0 (значение в скобках - это аргумент startValue, это было прописано в создании кастомного компонента и это же значение равно состоянию count, это было прописано там же, в скобках создании хука useState, поэтому, прописав у хука useCounter в скобках 0, мы говорим то, что состояние count равно 0).
  
 return( 					//Компонент App будет рэндерить абзац в котором будет значение состояния count, и также две кнопки которые при нажатии будут выполнять функции up и down соотвецтвено.
   <p>{count}</p>
   <button onClick={up}>Up</button>
   <button onClick={down}>Down</button>
 )
}


_______



React работа с библиотекой Axios

Некоторые базы данных можно получить на сайте JSONPlaceholder

Axios - это библиотека JavaScript, которая предоставляет удобные методы для выполнения HTTP-запросов из браузера или Node.js. Она является одной из наиболее популярных библиотек для работы с HTTP-запросами и широко используется во многих проектах, включая React.

Для подключения Axios к React проекту вам потребуется выполнить несколько шагов:

1.Установите Axios: В вашем проекте откройте командную строку или терминал и выполните команду установки Axios с помощью пакетного менеджера npm
npm install axios

2.Импортируйте Axios: В файле компонента, где вы хотите использовать Axios, добавьте следующую строку импорта в начало файла:
import axios from 'axios';


У axios есть несколько типов запросов: get, post, put и delete.


GET-запрос (axios.get): GET-запрос используется для получения данных с сервера. Вы можете отправить GET-запрос с помощью метода axios.get(url), где url - ссылка сервера, с которрого будут братся данные.

Пример:

let [data, setData] = useState([]); //Создаем массив, в который позже засуним данные из сервера.

axios.get('ссылка сервера')
  .then(response => { //response - это все что хранилось на сервере.
    // Обработка полученных данных
    console.log(response.data); //data - это массив элементов, которые хранятся в response (Нужно знать, что response - это не только массив элементов, а и много других данных сервера, а вот массив элементов - это свойство у response, то есть data).
    setData(response.data) //Засовываем данные из сервера 
  })
  .catch(error => {
    // Обработка ошибки
    console.error(error);
  });


response - это те данные, которые хранит сервер. Если ссылка в axios.get была верной, то выполниться then и аргументом мы получим как раз таки response, у response есть массив data, в котором хранятся элементы.
Нужно создать состояние и в него передать response.data, а потом обращатся через это состояние к свойствам responce.data.
Также кроме then нужно еще использовать catch, он будет выполнять код, которй написан в нем при ошибке (Тоесть тогда, когда ссылка неверна).


POST-запрос (axios.post): POST-запрос используется для отправки данных на сервер для создания новых ресурсов или выполнения других операций записи.
Вы можете отправить POST-запрос с помощью метода axios.post(url, data), где url - ссылка сервера, data - данные, которые вы хотите отправить

Пример:

axios.post('ссылка на сервер', {id: 101, userId: 11, title: 'Hello', body: 'world'})
   .then((response) => { //Тут response - это все данные которые мы отправили, из которых data - это отправившийся новый элемент.
      console.log(response.data);
      setData([...data, response.data])
    })
    .catch((error) => {
      console.error(error)
    })


PUT-запрос (axios.put): PUT-запрос используется для обновления существующих елементов на сервере. Вы можете отправить PUT-запрос с помощью метода axios.put(url, data), где url - ссылка сервера и идентификатор ресурса, data - данные, которые вы хотите обновить

Пример:

axios.put('ссылка на сервер/id элеменента, который меняеться', newEl) //newEl - это элемент, который заменит старый, тот у которого id = тому, что мы написали после URL ссылки на сервер.
   .then((response) => { ////Тут response - это все данные которые мы отправили, из которых data - это  newEl.
     setData(data.map(el => {
      if (el.id === response.data.id) { //Если id элемента, который мы сейчас проверяем === id элемента, на который мы заменыем, то...
       return {...newEl}; //...Возвращать элементу, который мы сейчас проверяем свойства нового элемента
      }
      return el; //Возвращам в массив data элемент el, который сейчас проверяем.
     }) //То есть те элементы массива data, у которых id != id элемента, на который мы заменяем остаються неизменными, а тот элемент у которого id == id элемента, на который мы заменяем тоже остаеться, но у него меняются свойства
    );
   })
   .catch((error) => {
     console.error(error);
   })

DELETE-запрос (axios.delete): DELETE-запрос используется для удаления ресурсов на сервере.
Вы можете отправить DELETE-запрос с помощью метода axios.delete(url), где url - адрес сервера и идентификатор ресурса

Пример:

axios.delete('ссылка на сервер/id элеменента, который удаляеться')
   .then((response) => { //response - это элемент, который удаляеться
     setData(data.filter(el => el.id !== нужный id)); //Фильтрируем массив элементов, но у элемента, который сейчас проверяеться id не должен быть равен нужному id, если же id = нужному id, то он не проходит в массив.
    })
